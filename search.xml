<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《神经网络与深度学习》读书笔记]]></title>
    <url>%2F2017%2F12%2F10%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 使用神经网络识别手写数字感知器 感知器在20世纪五、六十年代由科学家Frank Rosenblatt发明，其受到Warren McCulloch和Walter Pitts早期的工作影响。一个感知器接受几个二进制输入，$x_1,x_2,…,$,并产生一个二进制的输出： 示例中的感知器有三个输入，$x_1,x_2,x_3$,通常可以有更多或更少的输入，通过引入相应的权重，$w_1,w_2,…$表示相应输入对于输出的重要性的实数。神经元的输出，0或者是1，则由分配权重后的总和$\sum_{j}w_jx_j$小于或大于一些给定的阈值决定。和权重一样，阈值是一个实数，一个神经元的参数。可以用下面的形式来表示： 简化一下感知器的数学描述，用$w·x=\sum_{j}w_jx_j,b=-threshold$,则感知器的规则可以重写为： S型神经元单个感知器上一个权重或偏置的微小改动有时会引起那个感知器的输出完全翻转，如从0变到1。这样的翻可能接下来引起其余网络的行为以极其复杂的方式完全改变。因此，虽然有时可以正确对一类进行分类，但网络在其他图像的行为很可能以一些很难控制的方式被完全改变。这使得逐步修改权重和偏置来让网络接近期望行为变得很困难。 可以引入一种称为S型神经元来克服这个问题。S型神经元和感知器类似，但是被修改为权重和偏置的微小改动只引起输出的微小变化。这对于让神经元网络学习起来是很关键。S型神经元同样有多个输入，$x_1,x_2,…$，对应每个输入有权重，$w_1,w_2,…$和一个总的偏置，b。但是输出不是0和1，而是$\sigma(w·x+b)$,$\sigma$被称为S型函数，定义为：$$\sigma(z)=\frac {1}{1+e^{-z}}$$可以看到：当$z=w·x+b$为很大的正数时，S型神经元的输出近似为1；当$z=w·x+b$为很小的负数时，S型神经元的输出近似为0。这种行为与感知器很像，只有在$w·x+b$取中间值时，和感知器模型有比较大的偏离。S型函数的形状如下： 利用S型神经元，会得到一个平滑的感知器。$\sigma$是平滑的，利用其特性，权重和偏置的微小变化会输出一个为微小的变化，不会像感知器那样变化剧烈。### 神经网络的架构一个典型的神经网络架构如下图所示： 主要包括：输入神经元、隐藏层和输出神经元三个部分。以上一层的输出作为下一层的输入，这种网络被称为前馈神经网络。这意味着网络中是没有回路的-信息总是向前传播，从不反向回馈。### 使用梯度下降算法进行学习使用神经网络构建手写体识别分类算法，使用二次代价函数作为损失函数，训练神经网络找到最小化二次代价函数C(w,b)的权重和偏置。： 为什么使用二次代价，而不是直接最大化正确分类图像的数量？因为，在神经网络中，被正确分类的图像数量关联权重和偏置的函数并不是一个平滑的函数。大多数情况下，对权重和偏置做出的微小变动完全不会影响被正确分类的图像的数量。这会导致很难去解决如何改变权重和偏置来取得改进的性能。而用一个类似二次代价的平滑代价函数则能更好地解决如何用权重和偏置中的微小改变来取得更好的效果。梯度下降法假设我们要最小化某些函数，$C(v)$。它可以是任意的多元实值函数，$v=v_1,v_2,…$，用v代替w和b以强调它可能是任意的函数，并不局限于神经网络的环境。为了最小化$C(v)$，想象C是一个只有两个变量$v_1$和$v_2$的函数，如下图所示： 如果在$v_1$和$v_2$方向上分别改变很小的量，即$\Delta v_1$和$\Delta v_2$，微积分告诉我们$C$将会有如下变化：$$\Delta C \approx \frac {\partial C}{\partial v_1}\Delta v_1 + \frac {\partial C}{\partial v_2}\Delta v_2 $$因为，我们要最小化$C$，所以要寻找中选择$\delta v_1$和$\delta v_2$的方法，使得$\Delta C$为负；为了弄明白如何选择，需要定义$\delta v$为v变化的向量，$\Delta v= (\Delta v_1,\Delta v_2)^T$；定义$C$的梯度为偏导数的向量$\nabla C$:$$\nabla C =(\frac {\partial C}{\partial v_1},\frac {\partial C}{\partial v_2})^T$$那么，$$\Delta C \approx \nabla C · \Delta v$$这个表达式解释了为什么$\nabla C$被称为梯度向量：$\nabla C$把v的变化关联为$C$的变化，正如我们期望的用梯度来表示。如果选取：$$\Delta v=-\eta \nabla C$$那么，可以看到$\Delta C \approx -\eta \nabla C · \nabla C = -\eta ||\nabla C||^2$ 是永远小于等于0的，如果按照这种方式去改变v，那么$C$会一直减小，不会增加。因此，可以用如下方式更新$v$:$$v \rightarrow v^{new} = v - \eta \nabla C$$然后用它再次更新规则来计算下一次的更新，如果反复持续这样做，我们将持续减小C直到获得一个全局的最小值。如果$C$是一个具有更多变量的函数，也同样适用。梯度下降法就是通过这种方式重复改变$v$来找到函数$C$的最小值。如何在神经网络中使用梯度下降法去学习呢？其思想就是利用梯度下降算法去寻找能使得代价函数取得最小值的权重$w_k$和偏置$b_l$。我们将权重和偏置代替变量$v_j$，那么可以得到：$$w_k \rightarrow w_k^{new} = w_k - \eta \frac {\partial C}{\partial w_k}\\\\b_l = b_l^{new}=b_l - \eta \frac {\partial C}{\partial b_l}$$随机梯度下降，就是通过随机选取小量的训练输入样本来计算$\nabla C_x$,进而估计梯度$\nabla C$。通过计算少量的样本的平均值可以快速得到一个对于实际梯度$\nabla C$的很好的估算，有助于加速梯度下降，进而加速学习过程。批量梯度下降，随机选取小批量的数据，在这批数据上计算梯度，并更新参数。## 第二章 反向传播算法是如何工作的### 反向传播算法的推导首先，定义神经网络中的权重，我们使用$w_{jk}^l$表示从(l-1)层的第k个神经元到l层的第j个神经元的连接上的权重。如下图所示：同时，我们使用$b_{j}^l$表示在第l层第j个神经元的偏置，使用$a_j^l$表示第l层第j个神经元的激活值，下图清楚地解释了这样表示的含义：于是，第l层的第j个神经元的激活值$a_j^l$就和第(l-1)层的激活值通过下面的公式联系起来$$a_j^l = \sigma(\sum_k w_{jk}^la_k^{l-1} + b_j^l)$$对每一层l都定义一个权重矩阵$w^l$,表示连接到第l层神经元的权重，同时，每一层，定义一个偏置向量，$b^l$。于是，第l层的激活值向量$a^l$可以写成如下形式：$$a^l = \sigma(w^l a^{l-1} + b^l)$$这个表达式给出了一种更加全局的思考每层的激活值和前一层激活值的关联方式：我们仅仅用权重矩阵作用在激活值上，然后加上一个偏置向量，最后作用于$\sigma$函数。在计算$a^l$的过程中，我们计算了中间量$z^l = w^la^{l-1}+b^l$，我们称其为l层神经元的带权输入，这样$a^l = \sigma(z^l)$。其次，看一下神经网络代价函数的两个假设。上一章使用的是二次代价函数： 其中，n是训练样本总数；求和运算遍历了每个训练样本x；y=y(x)是对应的目标输出；L表示网络的层数；$a^L=a^L(x)$是当输入是x时网络输出的激活值向量。反向传播的目标是计算代价函数$C$分别关于w和b的偏导数，为了让反向传播可行需要作出以两个假设：第一个假设就是代价函数可以被写成一个在每个训练样本x上的点检函数$C_x$的均值$C=\frac {1}{n} \sum_x C_x$。需要这个假设的原因是反向传播实际上是对一个独立的训练样本计算了$\frac {\partial C_x}{\partial w}$和$\frac {\partial C_x}{\partial b}$。然后，我们通过在所有训练样本上进行平均化获得$\frac {\partial C}{\partial w}$和$\frac {\partial C}{\partial b}$。实际上，有了这个假设，我们会认为训练样本x已经被固定住了，丢掉了其下标，将代价函数$C_x$看做$C$。第二个假设就是代价函数可以写成神经网络输出的函数： 最后，反向传播算法的推导。 反向传播其实是对权重和偏置变化影响代价函数的过程的理解。最终极的含义其实就是计算偏导数$\frac {\partial C}{\partial w_{jk}^j}$和$\frac {\partial C}{\partial b_j^l}$。为了计算这些值，首先引入一个中间量$\delta_j^l$，称为在第l层第j个神经元上的误差。反向传播将给出计算误差$\delta_j^l$的流程，然后将其关联到计算$\frac {\partial C}{\partial w_{jk}^j}$和$\frac {\partial C}{\partial b_j^l}$上。 反向传播的4个基本方程：(1) 输出层误差的方程，$\delta^L$,每个元素定义如下：$$\delta_j^L = \frac {\partial C}{\partial a_j^L}\sigma^\prime{(z_j^L)} (BP1)$$(2) 使用下一层的误差$\delta^{l+1}$ 来表示当前的误差$\delta^l$:$$\delta ^l = ((w^{l+1})^T \delta^{l+1})\bigodot\sigma^\prime(z^l) (BP2)$$其中，$(w^{l+1})^T$是第l+1层的权重矩阵$w^{l+1}$的转置。(3) 代价函数关于网络中任意偏置的改变率：$$\frac {\partial C}{\partial b_j^l} = \delta_j^l (BP3)$$(4) 代价函数关于任何一个权重的改变率：$$\frac {\partial C}{\partial w_{jk}^l} = a_k^{l-1}\delta_j^l (BP4)$$现在证明这四个基本的方程，所有的这些都是多元微积分的链式法则的推论。首先，从方程(BP1)开始，它给出了输出误差$\delta^L$的表达式。首先有如下的定义：$$\delta_j^L=\frac {\partial C}{\partial z_j^L}$$表示L层上第j个神经元的误差，应用链式法则，可以用输出激活值的偏导数的形式重新表示上面的偏导数：$$\delta_j^L=\sum_k \frac {\partial C}{\partial a_k^L}\frac {\partial a_k^L}{\partial z_j^L}$$这里求和是在输出层的所有神经元k上运行的。当然，第k个神经元的输出激活值$a_k^L$只依赖于当k=j时第j个神经元的输入权重$z_j^L$。所以，当k不等于j时$\partial a_k^L/\partial z_j^L$消失了。结果我们可以简化上一个方程为：$$\delta_j^L=\frac {\partial C}{\partial a_j^L}\frac {\partial a_j^L}{\partial z_j^L}$$于是，由$a_j^L=\sigma(z_j^L)$,上式右边的第二项可以写成$\sigma^\prime(z_j^L)$，方程就变成：$$\delta_j^L = \frac {\partial C}{\partial a_j^L}\sigma^\prime{(z_j^L)}$$下一步，证明（BP2），它给出了以下一层误差$\delta ^{l+1}$的形式表示误差$\delta^l$。为此，我们想要以$\delta_k^{l+1}=\partial C/ \partial z_k^{l+1}$的形式重写$\delta_j^l=\partial C/\partial z_j^l$。我们可以应用链式法则：$$\delta_j^l = \frac {\partial C}{\partial z_j^l}=\sum_k \frac {\partial C}{\partial z_k^{l+1}} \frac {\partial z_k^{l+1}}{\partial z_j^l}=\sum_k \frac {\partial z_k^{l+1}}{\partial z_j^l}\delta_k^{l+1}$$这里，最后一行交换了右边两项，并用$\delta_k^{l+1}$的定义带入。为了对最后一样的最后一项进行求值，注意：$$z_k^{l+1}=\sum_j w_{kj}^{l+1}a_j^l = \sum_j w_{kj}^{l+1}\sigma(z_j^l)+b_k^{l+1}$$做微分，我们得到：$$\frac {\partial z_k^{l+1}}{\partial z_j^l}=w_{kj}^{l+1}\sigma^\prime(z_j^l)$$带入，就可得到：$$\sigma_j^l = \sum_k w_{kj}^{l+1}\sigma_k^{l+1}\sigma^\prime(z_j^l)$$总结一下 ### 反向传播算法反向传播算法给出了一种计算代价函数梯度的方法。用算法描述出来就是： ## 第三章 改进神经网络的学习方法### 交叉熵代价函数使用sigmod作为激活函数，使用二次代价函数作为损失函数时，当神经元的输出接近1的时候，曲线变得相当平，$\sigma^\prime(z)$就很小，相应计算出的梯度也会非常小，学习的速度就会变慢。假设神经元的输出为$a=\sigma(z)$,其中，$z=\sum_j w_jx_j+b$是输入的带权和。我们定义这个神经元的交叉熵代价函数：$$C = -\frac {1}{n}\sum_x[yln a + (1-y)ln(1-a)]$$其中，n是训练样本总数，求和是在所有的训练输入x上进行的，y是对应的目标输出。交叉熵为何能够解释成一个代价函数？将交叉熵看做是代价函数有两点原因。第一，它是非负的，C&gt;0。第二，如果对于所有的训练输入x，神经元实际的输出接近目标值，那么交叉熵接近0，假设在这个例子中，y=0而a接近0，交叉熵的值为接近于0，反之y=1而a接近于1，交叉熵的值也接近于0，所以，在实际输出和目标输出之间的差距越少，最终的较差熵的值就越低。综上所述，交叉熵是非负的，在神经元达到很好的正确率的时候接近0。交叉熵代价函数有一个比二次代价函数更好的特性就是它避免了学习速度下降的问题。首先，看一下交叉熵函数关于权重的偏导数，将$a=\sigma(z)$带入交叉熵损失函数，应用链式法则，得到： 将结果合并一下，简化成： 最终，可以得到： 可以看到，权重的学习的速度受到$\sigma(z)-y$，也就是输出中的误差的控制。更大的误差，更快的学习速度。特别地，这个代价函数还避免了像二次代价函数类似方程中$\sigma^\prime(z)$导致学习的缓慢。交叉熵代价函数的学习曲线：特别地，当我们使用二次代价函数时，学习在神经元犯了明显的错误时却比学习快接近真实值的时候缓慢；而使用交叉熵学习正是在神经元犯了明显错误的时候速度更快。特别地，当我们使用二次代价函数时，当神经元在接近正确的输出前犯了明显错误的时候，学习变得更加缓慢；而使用交叉熵，在神经元犯明显错误时学习得更快。这些现象不依赖于如何设置学习速率。s### 过度拟合和规范化过度拟合是神经网络的一个主要问题。这在现代网络中特别正常，因为网络权重和偏置数量巨大。检测过度拟合的明显方法是使用上面的方法-跟踪测试数据集合的准确率随训练变化情况。如果我们看到测试数据上的准确率不再提升，那么我们就停止训练。严格地说，这其实并非是过度拟合的一个必要现象，因为测试集和训练集上的准确率可能会同时停止提升。当然，采用这样的策略是可以防止过度拟合的。使用validation_data而不是test_data来防止过度拟合，在每个迭代期的最后都计算在validation_data上的分类准确率。一旦分类准确率已经饱和，就停止训练。这个策略被称为early stopping。在实际应用中，我们不会立即知道什么时候准确率会饱和。相反，我们会一直训练直到我们确信准确率已经饱和。为何要使用validation_data来代替test_data防止过度拟合问题？实际上，这是一个更为一般的策略的一部分，这个一般的策略就是使用validation_data来衡量不同的超参数（如迭代次数、学习速率、最好的网络架构等等）的选择的效果。如果设置超参数是基于test_data的话，可能最终我们得到过度拟合于test_data的超参数，这些超参数符合test_data的特点，但是网络的性能并不能够泛化到其他的数据集合上。我们借助validation_data来克服这个问题，一旦获得了想要的超参数，最终我们就使用test_data进行准确率测量。规范化增加训练样本的数量是一种减轻过度拟合的方法。还有其他的一些方法能够减轻过度拟合，就是规范化，有时被称为权重衰减(weight decay)或者L2规范化。L2规范化的思想就是增加一个额外的项到代价函数上，这个项叫做规范化项。下面是规范化的较差熵: 可以看出，规范化的效果是让网络倾向于学习小一点的权重，其他的东西都是一样的。大的权重只有能够给出代价函数第一项足够的提升时才被允许。换而言之，规范化可以当做一种寻找小的权重和最小化原始的代价函数之间的折中。这两部分之前相对的重要性就由$\lambda$的值来控制了：$\lambda$越小，就偏向于最小的原始代价函数，反之，倾向于小的权重。新的权重的学习规则就变成： 这正和通常的梯度下降学习规则相同，除了通过一个因子$1-\frac {n\lambda}{n}$重新调整了权重$w_0$。这种调整有时被称为权重衰减，因为它使得权重变小。我们已经把规范化描述为一种减轻过度拟合和提高分类准确率的方法。实际上，这不是仅有的好处。实践表明，在使用不同的权重初始化进行多次MNIST网络训练的时候，我们发现无规范化的网络会偶然被限制住，明显困在了代价函数的局部最优值处。结果就是不同的运行会给出相差很大的结果。对比看来，规范化的网络能够提供更容易复制的结果。为什么会这样子呢？，从经验上来看，如果代价函数是无规范化的，那么权重向量的长度可能会增长，而其他的东西都保持一样。随着时间的推移，这会导致权重向量变得非常大。所以会使得权重向量卡在朝着更多还是更少的方向上变化，因为当长度很大的时候梯度下降带来的变化仅仅会引起在那个方向发生微小的变化。我们相信这个现象让我们的学习算法更难有效地探索权重空间，最终导致很难找到代价函数的最优值。为何规范化可以帮助减轻过度拟合？通常的说法是：小的权重在某种程度上，意味着更低的复杂性，也就对数据给出了一种更简单却更强大的解释，因此应该优先选择。L2规范化没有限制偏置，实际上可以对偏置进行限制，但在某种程度上，对不对偏置进行规范化其实就是一种习惯了。然而，需要注意的是，有一个大的偏置并不会向大的权重那样会让神经元对输入太过敏感。所以，我们不需要对大的偏置带来的学习训练数据的噪声太过担心。同时，允许大的偏置能够让网络更加灵活，因为，大的偏置让神经元更加容易饱和，这有时候是我们所要达到的效果。所以，我们通常不会对偏置进行规范化。规范化的其他技术除了L2外还有很多规范化技术，另外给出三种减轻过拟合的其他方法：L1规范化、弃权和人为增加训练样本。L1规范化：这个方法是在未规范化的代价函数上加上一个权重绝对值的和：$$C=C_0 + \frac{\lambda}{n} \sum_w |w|$$在L1规范化中，权重通过一个常量向0进行缩小。在L2规范化中，权重通过一个和w成比例的量进行缩小。所以，当一个特定的权重绝对值|w|很大时，L1规范化的权重缩小得要远比L2规范化要小的多、相反，当一个特定的权重绝对值|w|很小时，L1规范化的权重缩小得要比L2规范化大的多。最终的结果是：L1规范化倾向于聚集于网络的权重在相对少量的高重要度连接上，而其他权重就会被驱使向0接近。弃权(DropOut)是一种相当激进的技术。和L1、L2规范化不同，弃权技术并不依赖对代价函数的修改。而是，在弃权中，我们改变了网络本身。弃权技术在训练大规模深度网络时尤其有用，这样的网络中过度拟合问题经常特别突出。人为扩展训练数据### 权重初始化在创建了神经网络后，我们需要进行权重和偏置的初始化。之前的方式是根据独立高斯随机变量来选择权重和偏置，其被归一化为均值0，标准差1。假设我们使用一个有大量输入神经元的网络，比如说1000个。假设，我们已经使用归一化的高斯分布初始化了连接的第一个隐藏层的权重。现在我们将注意力集中在这一层的连接权重上，忽略网络的其他部分： 为了简化，假设我们使用训练输入x,其中一半的输入神经元的值为1，另一半为0。以下的论点更普遍适用，让我们考虑隐藏神经元输入的带权和$z=\sum_j w_jx_j+b$。其中，500个项消去了，因为对应的输入$x_j$为0。所有z是遍历总共501个归一化的高斯随机变量的和，包含500个权重项和额外的1个偏置项。因此，z本身是一个均值为0,标准差为22.4的高斯分布。z其实有一个非常宽的高斯分布，完全不是非常尖的形状： 尤其是，我们可以从上图看出|z|会变得非常大，如果这样，隐藏神经元的输出$\sigma(z)$就会接近1或0。也就表示我们的隐藏神经元会饱和。所以，当出现这样的情况时，在权重中进行微小的调整仅仅会给隐藏神经元的激活值带来极其微弱的改变。而这种微弱的改变也会影响网络中剩下的神经元，然后会带来相应的代价函数的改变。结果就是，这些权重在我们进行梯度下降算法时会学习得非常缓慢。我们可以进行更好地初始化，能够避免这种类型的饱和，最终避免学习速度的下降，假设我们有n个输入神经元，我们可以使用均值为0标准差为$1/\sqrt[]{n}$的高斯随机分布初始化这些权重。也就是说，我们会向下挤压高斯分布，让我们的神经元更不可能饱和。## 第五章 深度神经网络为何很难训练当神经网络层数加深，先前的层可能学习的比较好，但是后面的层却停滞不变。实际上，我们发现，在深度神经网络中使用基于梯度下降的学习方法本身存在着内在的不稳定性。这种不稳定性使得先前或者后面的层的学习过程阻滞。### 消失的梯度问题在某些深度神经网络中，在我们在隐藏层BP的时候梯度倾向于变小。这意味着在前面的隐藏层中的神经元学习速度要慢与后面的隐藏层。在很多神经网络中存在着更加根本的导致这个现象出现的原因。这个现象也被称作是消失的梯度问题（vanishing gradient problem）更一般地说，在深度神经网络中的梯度是不稳定的，在前面的层中或会消失或会爆炸。这种不稳定性才是神经网络中基于梯度学习的根本问题。下图是一个有三层隐藏层的神经网络： 其中，$w_1,w_2,…$是权重,而$b_1,b_2,…$是偏置，C是某个代价函数。现在看一下关联于第一个隐藏层神经元梯度$\partial C/ \partial b_1$。下图给出了具体的表达式：为何会出现梯度消失：现在把梯度的整个表达式写下来： 除了最后一项，该表达是一系列形如$w_j\sigma^\prime(z_j)$的乘积。如果我们使用标准方法来初始化网络中的权重，那么会使用一个均值为0标准差为1的高斯分布。因此，所有的权重通常会满足$|w_j|&lt;1$。有了这些信息，我们就会发现$w_j\sigma^\prime(z_j)&lt;1/4$。并且在我们进行了所有这些项的乘积时，最终的结果肯定会指数级下降：项越多，乘积下降的越快。这样就能够解释消失的梯度问题。 不稳定的梯度问题：根本问题其实并非是消失的梯度问题或者爆炸的梯度问题，而是在前面的层上的梯度是来自后面的层上的乘积。当存在过多的层次时，就出现了内在本质上的不稳定场景。唯一让所有层都接近相同的学习速度的方式是所有这些项的乘积都能得到一种平衡。如果没有某种机制或者更加本质的保证来达成平衡，那网络就很容易不稳定了。简而言之，真实的问题就是神经网络受限于不稳定梯度的问题。所以，如果我们使用标准的基于梯度的学习算法，在网络中的不同层会出现按照不同学习速度学习的情况。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识图谱技术综述]]></title>
    <url>%2F2017%2F11%2F11%2F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[本文主要是对《知识图谱技术综述》 徐增林等人的这篇论文阅读时的一个整理和记录。知识图谱技术是AI技术的重要组成部分，建立的具有语义处理能力与开放互联能力的知识库，可在智能搜索、智能问答、个性化推荐等智能信息服务中产生应用价值。这篇论文全面介绍了知识图谱的定义、架构以及知识图谱的知识抽取、知识表示、知识融合、知识推理四大核心技术的研究进展。 思维导图 知识图谱的定义与架构知识图谱的定义知识图谱是Google用于增强其搜索引擎功能的知识库。本质上，知识图谱是一种揭示实体之间关系的语义网络，可以对现实世界的事物及其相互关系进行形式化地描述。现在知识图谱以被用来泛指各种大规模的知识库。三元组是知识图谱的一种通用表示方式，即G=(E,R,S)，其中： G：表示知识库 E：表示知识库中的所有实际的集合 R：表示知识库中的关系集合 S：表示知识库中的三元组集合，$S \subseteq E \times R \times S $ 三元组的基本形式主要包括实体1、关系、实体2和概念、属性、属性值等，实体是知识库中最基本的元素，不同的实体之间存在不同的关系。概念主要指集合、类别、对象类型、事物的种类，例如人物、地理等；属性主要指对象可能具有的属性、特征、特性、特点及参数，例如国籍、生日等；属性值主要指对象指定属性的值，例如中国、1988-09-08等。每个实体可以用一个全局唯一确定的ID来标识，每个属性-属性值对（atrribute-value pair，AVP）可用来刻画实体的内在特性，而关系可用来连接两个实体，刻画它们之间的关联。 从覆盖范围而言，知识图谱可以分为通用知识图谱和行业知识图谱。通用知识图谱注重广度，强调融合更多的实体，较行业知识图谱而言，其准确度不够高，并且受概念范围的影响，很难借助本体库对公理、规则以及约束条件的支持能力规范其实体、属性、实体间的关系等。通用的知识库主要用于智能搜索等领域。行业知识图谱通常需要依靠特定的行业的数据来构建，具有特定的行业意义。行业知识图谱中，实体的属性与数据模式往往比较丰富，需要考虑到不同的业务场景与使用人员。 知识图谱的架构知识图谱的架构主要包括自身的逻辑结构以及体系架构。 1）知识图谱的逻辑结构知识图谱在逻辑上可以分为模式层与数据层两个层次。数据层主要是由一系列的事实组成，而知识将以事实为单位进行存储。可选择图数据库作为存储介质，例如开源的Neo4j、Twitter的FlockDB、seones的GraphDB。模式层构建在数据层之上，主要是通过本体库来规范数据层的一系列事实表达。本体是结构化知识库的概念模板，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度叫较小。 2）知识图谱的体系架构知识图谱的体系架构是指构建模式结构，如下图所示（图引自该论文） 知识图谱主要有自顶向下(top-down)与自底向上(bottom-up)两种构建方式。自顶向下指是先为知识图谱定义好本体与数据模式，再将实体加入到知识库。该构建方式需要利用一些现有的结构化知识库作为其基础的知识库，例如Freebase就是采用这种方式，它的绝大部分数据是从维基百科中得到的。自底向上指的是从一些开放链接数据中提取出实体，选择其中置信度较高的加入到知识库，再构建顶层的本体模式。目前，大多数知识图谱都采用自底向上的方式进行构建，其中最典型的就是Google的Knowledge Vault。 大规模知识库案例随着语义web资源数量激增、大量的RDF数据被发布和共享、LOD(linked open data)等项目的全面展开，学术界和工业界的研究人员花费了大量的精力构建各种结构化知识库。主要包括开放链接知识库、行业知识库两类。 开放链接知识库在LOD项目的云图中FreeBase、Wikidata、DBpedia、YAGO这4个是比较重要的大规模知识库。它们中不仅包含大量的半结构化、非结构化数据，是知识图谱数据的重要来源。而且具有较高的领域覆盖面，与领域知识库存在大量的关系。 垂直行业知识库行业知识库也可以称为垂直型知识库，这类知识库的描述目标是特定的行业领域，通常需要依靠特定行业的数据才能构建，因此其描述范围极为有限。下面几个就是比较典型的垂直行业知识库。 IMDB，是一个关于电影演员、电影、电视节目、电视明星以及电影制作的治疗库。 MusicBrainz,是一个结构化的音乐维基百科，致力于收藏所有的音乐元数据，并向大众用户开放。 ConceptNet,是一个语义知识网络，主要由一系列代表概念的结点构成，这些概念将主要采用自然语言单词或短语的表达形式，通过相互连接建立语义联系。 知识图谱的关键技术大规模知识库的构建与应用需要多种智能信息处理技术的支持。主要包括以下技术： 知识抽取：从一些公开的半结构化、非结构化的数据中提取出实体、关系、属性等知识要素。 知识融合：消除实体、关系、属性等指称项与事实对象之间的奇异，形成高质量的知识库。 知识推理：在已有的知识库的基础上，进一步挖掘隐含的知识，从而丰富、扩展知识库。 知识表示：以某种方式表示知识 下面就分别介绍相关的技术。 知识抽取知识抽取主要是面向开放的链接数据，通过自动化的技术抽取出可用的知识单元，知识单元主要包括实体、关系以及属性3个知识要素，并以此为基础，形成一系列高质量的事实表达，为上层模式层的构建奠定基础。 (1) 实体抽取实体抽取，也称为命名实体识别，指的是从原始预料自动识别出命名实体。实体抽取主要分为3种方法： 基于规则与词典的方法 基于统计机器学习的方法 面向开放域的抽取方法 (2) 关系抽取关系抽取的目标是解决实体间的语义链接问题，早期的关系抽取主要是通过人工构造语义规则以及模板的方法识别实体关系。随后，实体间的关系模型逐渐代替了人工预定义的语法与规则。但是，仍需要提前定义实体间的关系类型。后来出现面向开放域的信息抽取框架(open information extraction,OIE),这是抽取模式上一个巨大进步。但OIE方法在对实体的隐含关系抽取方面性能低下，因此，部分研究者提出基于马尔科夫逻辑网、基于本体推理的深层隐含关系抽取方法。 (3) 属性抽取属性抽取主要是针对实体而言的，通过属性可形成对实体的完整描述。由于实体的属性可以看成是实体与属性值之间的一种名称关系，因此可以将实体属性的抽取问题转换为关系抽取问题。大量的属性数据主要存在于半结构化、非结构化的大规模开放域数据集中。抽取这些属性的方法，一种是将上述从百科网站上抽取的结构化数据作为可用于属性抽取的训练集，然后再将该模型应用于开放域中的实体属性抽取；另一种，根据实体属性与属性之间的关系模式，直接从开放域数据集上抽取属性。但是，由于属性值附近普遍存在一些限定属性值定义的属性名等，所以该抽取方法的准确率并不高。 知识表示虽然，基于三元组的知识表示形式比较直观，但是其在计算效率、数据稀疏性等方面面临着诸多问题。以Deep Learning为代表的表示学习技术可以将实体的语义信息表示为稠密低维实值向量，进而在低维空间中高效计算实体、关系及其之间的复杂语义关联，对知识库的构建、推理、融合及应用均具有重要的意义。 (1) 应用场景分布式表示旨在用一个综合向量表示实体对象的语义信息，是一种模仿人脑工作的表示机制，通过知识表示而得到的分布式表示形式在知识图谱的计算、补全、推理等方面将起到重要作用： 1）语义相似度计算。由于实体通过分布式表示而形成的是一个个低维的实值向量，所以，可使用熵权系数法、余弦相似性等方法计算它们之间的相似性。这种相似性刻画了实体之间的语义关联程度，为自然语言处理等提供了极大的便利。 2）链接预测。通过分布式表示模型，可以预测图谱中任意两个实体之间的关系，以及实体间存在的关系的正确性。尤其是在大规模知识图谱上下文中，需要不断补充其中的实体关系，所以链接预测又被称为知识图谱的不全。 (2) 代表模型知识表示学习的代表模型主要包括距离模型、双线性模型、神经张量模型、矩阵分解模型、翻译模型(TransE模型)等。 (3) 复杂关系模型知识库中的实体关系类型也可以分为1-to-1、1-to-N、N-to-1、N-to-N四种类型，复杂的关系主要指的是1-to-N、N-to-1、N-to-N的3种关系类型。由于TransE模型不能用在处理复杂关系上，一系列基于它的扩展模型纷纷被提出，主要包括：TransH模型、TransR模型、TransD模型、TransG模型和KG2E模型。 (4) 多源信息融合三元组作为知识库的一种通用的表示形式，通过表示学习，能够以较为直接的方式表说实体、关系及其之间的复杂语义关联。然而，互联网中仍蕴含着大量与知识库实体、关系有关的信息未被考虑或有效利用，如何充分融合、利用这些多源异质的相关信息，将有利于进一步提升现有知识表示模型的区分能力以及性能。目前，多源异质信息融合模型方面的研究尚处于起步阶段，涉及的信息来源也极为有限。 知识融合由于知识图谱中的知识来源广泛，存在知识质量良莠不齐、来自不同数据源的知识重复、知识间的关联不够明确等问题，所以需要进行知识的融合。知识融合是高层次的知识组织，使来自不同的知识源的知识在同一框架规范下进行异构数据整合、消歧、加工、推理验证、更新等步骤，达到数据、信息、方法、经验以及人的思想的融合，形成高质量的知识库。 实体对齐实体对齐(entity alignment)，也称为实体匹配或实体解析，主要用于消除异构数据中实体冲突、指向不明等不一致性问题，可以从顶层创建一个大规模的统一知识库，从而帮助机器理解多源异质的数据，形成高质量的知识。 在大数据环境下，受知识库规模的影响，在进行知识库实体对齐时，主要会面临以下3个方面的挑战：（1）计算复杂度；（2）数据质量，不同知识库的构建目的与方式不同，可能存在知识质量良莠不齐、相似重复数据、孤立数据、数据时间粒度不一致等等问题。（3）先验训练数据，在大规模知识库中想要获得这种先验数据却非常困难。通常情况下，需要手工构造训练数据。 基于上述，知识库实体对齐的主要流程包括： 将待对齐数据分区索引，以降低计算的复杂度； 利用相似度函数或相似性计算算法查找匹配实例； 使用实体对齐算法进行实例融合； 将步骤2和3的结果结合起来，形成最终的对齐结果。 对齐算法可以分为成对实体对齐和集体实体对齐两大类，而集体实体对齐又可分为局部集体对齐和全局集体对齐。 （1）成对实体对齐基于传统概率模型的实体对齐方法，主要是考虑两个实体各自属性的相似性，而不考虑实体之间的关系。基于机器学习的实体对齐方法，主要是将实体对齐问题转化为二分类问题。根据是否使用标注数据可分为有监督学习与无监督学习两类。 （2）局部集体实体对齐方法局部集体实体对齐方法为实体本身的属性以及与它有关联的实体的属性分别设置不同的权重，并通过加权求和计算总体的相似度，还可使用向量空间模型以及余弦相似度来判别大规模知识库中的实体的相似程度。 （3）全局集体实体对齐方法 知识加工通过实体对齐，可以得到一系列的基本事实表达或初步的本体雏形，然而事实并不等于知识，它只是知识的基本单位。要形成高质量的知识，还需要经过知识加工的过程，从层次上形成一个大规模的知识体系，统一对知识进行管理。知识加工主要包括本体构建与质量评估两方面的内容。 （1）本体构建本体是同一领域内不同主体之间进行交流、连通的语义基础，其主要呈现树状结构，相邻的层次结点或概念之间具有严格的”IsA”关系，有利于进行约束、推理等，却不利于表达概念的多样性。本体在知识图谱中的地位相当于知识库的模具，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度较小。 本体可以通过人工编辑的方式手动构建，也可以通过数据驱动自动构建，然后再经质量评估方法与人工审核相结合的方式加以修正和确认。数据驱动的本体自动构建过程主要可以分为以下3个阶段： 纵向概念间的并列关系计算。通过计算任意两个实体间并列关系的相似度，可辨析它们在语义层面是否属于同一个概念。计算方法主要包括模式匹配和分布相似度两种。 实体上下位关系抽取。上下位关系抽取方法包括基本语法的抽取与基本语义的抽取两种方式。 本体生成。对各个层次得到的概念进行聚类，并为每一类的实体指定1个或多个公共上位词。 （2）质量评估对知识库的质量评估任务通常是与实体对齐任务一起进行的，其意义在于，可以对知识的可信度进行量化，保留置信度较高的，舍弃置信度较低的，有效确保知识的质量。 知识更新人类的认知能力、知识储备以及企业需求都会随着时间而不断递增。因此，知识图谱的内容也需要与时俱进，不论是通用的知识图谱，还是行业知识图谱，它们都需要不断地迭代更新，扩展现有的知识，增加新的知识。 根据知识图谱的逻辑结构，其更新主要包括模式层的更新和数据层的更新。模式层的更新是指本体中元素的更新，包括概念的增加、修改、删除，概念属性的更新以及概念间上下位关系的更新。通常来说，模式层的增量更新方式消耗资源较少，但是多数情况下是在人工干预的情况下完成的。例如，需要人工定义规则，人工处理冲突等。数据层的更新指的是实体元素的更新，包括实体的增加、修改、删除，以及实体的基本信息和属性值。由于数据层的更新一般影响面较小，因此，通常以自动的方式完成。 知识推理知识推理则是在已有的知识库基础上进一步挖掘隐含的知识，从而丰富、扩展知识库。在推理的过程中，往往需要关联规则的支持。对于推理规则的挖掘，主要还是依赖于实体以及关系间的丰富同现情况。知识推理的对象可以是实体、实体的属性、实体间的关系、本体库中的概念的层次结构等。知识推理方法主要可以分为基于逻辑的推理和基于图的推理两种类别。 知识图谱的典型应用智能搜索基于知识图谱的智能搜索是一种基于长尾的搜索，搜索引擎以知识卡片的形式将搜索结果展现出来。用户的查询请求将经过查询式语义理解与知识检索两个阶段。 查询式语义理解。知识图谱对查询式的语义分析主要包括：（1）对查询请求文本进行分词、词性标注以及纠错；（2）描述归一化，使其与知识库中的相关知识进行匹配；（3）语境分析，在不同的语境下，用户查询式中的对象会有所差别，因此，知识图谱需要结合用户当时的情感，将用户此时需要的答案及时反馈给用户；（4）查询扩展，明确了用户的查询意图以及相关概念后，需要加入当前语境下的相关概念进行扩展。 知识检索。经过查询式语义分析后，标准查询语境进行知识库检索引擎，引擎会在知识库中检索相应的实体以及与其在类别、关系、相关性等方面匹配度较高的实体。通过对知识库的深层挖掘与提炼后，引擎将给出具有重要性排序的完整知识体系。 智能搜索引擎主要以3种形式展现知识： 集成的语义数据。例如，搜索梵高，搜索引擎将以知识卡片的形式给出梵高的生平，并配合图片等信息。 直接给出用户查询问题的答案。例如，用户搜索“姚明的身高是多少？”，搜索引擎的结果是“226cm”。 根据用户的查询给出推荐的列表等。 深度问答问答系统是信息检索系统的一种高级形式，能够以准确简洁的自然语言为用户提供问题的解答。多数问答系统更倾向于将给定的问题分解为多个小的问题，然后逐一去知识库中抽取匹配的答案，并自动检测其在时间与空间上的吻合度等，最后将答案进行合并，以直观的方式展现给用户。 社交网络知识图谱的挑战(1)知识获取(2)知识表示 复制关系中的知识表示 多源信息融合中的知识表示 (3)知识融合 并行与分布式算法 众包算法 跨语言知识对齐 (4)知识应用]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采样方法]]></title>
    <url>%2F2017%2F11%2F04%2F%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在前两周组内的技术分享中，分享了采样方法。之前在研究生阶段就对采样方法很是疑惑，特别是在看LDA时，用到的Gibbs采样，很多次尝试去学习这一知识点，但都一知半解。所以，借这个机会认真学习一下采样方法相关的知识。本文主要是记录一下自己在学习采样方法时，对不同采样方法原理的理解，主要包括蒙特卡洛方法介绍和5中不同的采样方法。 蒙特卡洛方法首先说一下蒙特卡洛方法，Monte Carlo方法，又称为统计模拟法、随机抽样技术，是一种随机模型方法，以概率和统计理论为基础的一种计算方法。是使用随机数（或伪随机数）来解决很多复杂问题的计算方法。其核心就是通过将所要求解的问题同一定的概率模型相联系，利用计算机进行模拟或抽样，以获得问题的近似解。简单地理解蒙特卡洛方法，其实就是将要解决的采用一定的方式进行转换，转换之后的问题通过利用计算机实现统计模拟或抽样，从而获得问题是近似解。至于为什么叫Monte Carlo方法，可能是和闻名世界的赌城——摩纳哥的一个小山城有关吧！具体是什么原因，不必去深究。 来看一个典型的用Monte Carlo方法解决实际问题的例子。计算圆周率Π的值，如果采用Monte Carlo方法进行计算，可以进行如下的转换： 首先，设置一个边长为1的正方形，其内有一圆，圆的半径为0.5，如下图所示： 随机的向正方形内打点，打的点在圆内的概率等于圆与正方形的面积之比0.25Π 随机产生M个点(x,y)，其中，x和y都是区间[0,1]内的符合均匀分布的随机数 假设落在圆内的点有N个，当M足够大时，根据大数定理，频率等于概率，就有：$$\frac {N} {M} = 0.25Π$$，$$Π=\frac {4N} {M}$$ 实际用代码去模拟一下，得出的圆周率的值为：3.143748，和3.1415926非常接近。 12345678def samplePI(maxCnt = 1000000):accCnt = 0for i in range(maxCnt): x = np.random.random() y = np.random.random() if np.sqrt(x**2 + y**2) &lt; 1: accCnt += 1print "PI=", float(accCnt) / maxCnt *4 通过一个简单的例子，可以直观地理解Monte Carlo方法。采样Monte Carlo方法去解决实际问题一般可以分为如下的步骤： 对复杂的问题进行转换，构造或描述随机过程。例如，将计算圆周率的问题，转换为在一个正方形内进行打点，将圆周率的值和点在圆内的概率联系起来。 从已知的概率分布中进行采样,采样出符合特定分布的样本。例如，从符合[0,1]均匀分布中采样出x和y。 建立估计量进行计算。 Monte Carlo方法是一种通用的计算技术，可以解决如下问题: 随机模拟：从一个pdf产生”典型”的样本 计算积分：在高维空间中的积分 优化问题 学习：MLE:f(x;Θ) 利用Monte Carlo方法去解决实际问题的第2步是从符合特定分布中采样出样本。我们知道，计算机本身无法产生真正的随机数，但可以根据一定的算法产生伪随机数。比如，通过线性同余发生器可以生成伪随机数，我们可以用确定性的算法生成[0,1]之间符合均匀分布的随机数，可以被当成真正的随机数使用。而至于产生符合比较复杂分布的随机数，则是以均匀分布为基础进行采样，以获得符合特定复杂分布的样本，这就是采样方法。不同的采样方法，采样过程不同，但大都基于均匀分布来进行的。下面就分别介绍，几种不同的采样方法。 Inverse Transform Sampling在介绍不同的采样方法之前，先说一下概率分布，概率分布一般分为连续型和离散型两种，离散型的概率分布一般用概率质量分布函数(pmf)表示，而连续分布用概率密度(pdf)表示,对pmf进行累加或对pdf进行积分的函数，对应于累积分布函数(cdf)。所有pmf的取值之和为1，对pdf在其定义域上进行积分，积分的值为1。对于一些简单的分布p(x),我们可以直接进行采样，比如，采样符合p(x)=[0.1,0.3,0.5,0.1]分布的样本 $x=x_1,x_2,x_3,x_4$分布，我们可以直接从Uniform(0,1)采样出一个数，x小于0.1，则采样的值为$x_1$,x等于0.1小于0.4则为$x_2$，以此进行类推。对于比较复杂的分布p(x)，不能直接进行采样。如果要采样的目标分布为p(x),它的累积分布函数F(x)能够求出来，F(x)的反函数也能求出来，那么，Inverse Transform Sampling的采样过程如下：123Inverse Transform Sampling1. 从Uniform(0,1)中随机采样一个点，用u表示。2. 计算$F^-1(u)$的值为x,则x就是服从p(x)的分布的一个样本点。 简单的证明一下：设F(x)为目标采样分布P(x)的累积分布，$x=F^{-1}(u) u\in[0,1]$为F(x)的反函数。因为F(x)是单调递增的(累积函数的性质)，所以$x=F^{-1}(u)$也是单调递增函数，对于如下不等式:$$F^{-1}(u)\leq F^{-1}(F(x)), if u \leq F(x) （1）$$根据反函数的定义有：$$F^{-1}(u) \leq x, if u \leq F(x) （2）$$根据Uniform(0,1)的定义，其累积分布函数如下： 所以，采样出的点的$F^{-1}(u)$累积分布函数如下：$$P(F^{-1}(u) \leq x)=P(u \leq F(x))=H(F(x))=F(x)$$由此可见，采样出的点的累积分布函数为F(x),所以，为符合p(x)分布的样本。虽然，利用这种方法可以采样出符合特定分布的样本，但是这种采样方法存在一个缺陷，即，如果要采样的分布p(x)累积分布函数不能够求出来或者累积分布函数没有反函数，这种方法就失效了 Acceptance-Rejection Sampling对于采样的目标分布p(x),如果其比较复杂，可以采用Acceptance-Rejection Sampling接受-拒绝采样，来进行采样。这种采样方法不直接对p(x)进行采样，而是选择另一个分布q(x)，存在常数M，使得$p(x)\leq Mq(x),\forall x $,称为建议分布(Proposal Density),这个分布容易进行采样，通过对q(x)的采样，来实现对p(x)的采样。其具体的采样过程如下：1234Acceptance-Rejection Sampling的采样过程：1. 从q(x)中随机采样出一个样本点x02. 在从Uniform(0, Mq(x0))中采样出另一个样本点u3. 如果u&gt;p(x0),则拒绝x0,并且重复前面的步骤。否则接受x0为符合p(x)分布的样本 这种采样方法可以用计算圆周率的方法来进行理解。把正方形看做一个分布Mq(x),圆形看做要采样的目标分布q(x),通过对Mq(x)进行随机采样，即打点，如点果落在圆内，表明该点符合圆形这个分布，即可以做符合p(x)的样本。即，如下图所示的圆内的点都是符合圆形这个分布的点。 Acceptance-Rejection Sampling，通过对q(x)的采样，实现了对p(x)的采样。这种采样方法的接受率正比于$\frac {1} {M}$,等于p(x)下面的面积除以Mq(x)下面的面积。可以看出，只有当M尽可能的小时，采样出的点被接受的概率才会大，从而可以提升采样的效率，因此在使用该方法进行采样是M的选择比较重要。同时,可以看出，如果q(x)和p(x)的形相似时，M就会越小，接受率就会越高。然而，对于高维的目标采样分布，q(x)可能不容易寻找，且M也可能会很大，此时，接受率就会变小，采样效率会变差。 Importance SamplingImportance Sampling 这种采样方法，其并不是为了获得符合特定分布p(x)的样本，而是为了解决当p(x)不容易进行采样时，计算E[f(x)]，x符合p(x)分布，的问题。其可以进行如下的转换：首先，根据期望的定义，E[f(x)]的计算公式如下：$$E[f(x)] = \int_x f(x)p(x)dx$$因为，p(x)的样本不容易获取，Importance Sampling同样引入一个建议分布q(x)，比较容易获取符合q(x)分布的样本，进行如下转换（以下内容参考：http://blog.csdn.net/dark_scope/article/details/70992266）：$$\int_x f(x)p(x)dx = \int_x f(x)\frac {p(x)} {q(x)} q(x) dx= \int_x g(x)q(x)dx where g(x)=f(x) \frac {p(x)} {q(x)} = f(x)w(x)$$可以看出，通过上面的转化，可以将计算f(x)在p(x)下的期望转化为求g(x)在q(x)分布下的期望。其中，$w(x) = \frac {p(x)} {q(x)}$被称为Importance Weight。但是，有些时候p(x)也是很难计算的，更常见的情况是比较方便的计算$\hat p (x)$和$\hat q(x)$$$p(x) = \frac {\hat p(x) }{Z_p}$$$$p(x) = \frac {\hat p(x)}{Z_p}$$其中，$Z_{p/q}$是一个标准化项，可以看成是一个常数，是的$\hat p(x)$或者$\hat q(x)$等比例变化为一个概率分布，也可以理解为softmax里的分母。其中：$$Z_p=\int_x \hat p(x)dx$$$$Z_q=\int_x \hat q(x)dx$$在这种情况下，Importance Sampling 可以进行如下的转换：$$ \int_x f(x)p(x)dx=\int_x f(x)\frac {p(x)} {q(x)} q(x)dx\\\\ =\int_x f(x) \frac {\hat p(x)/Z_p} {\hat q(x)/Z_q} q(x)dx\\\\=\frac {Z_q}{Z_p} \int_x f(x) \frac {\hat p(x)}{\hat q(x)}\\\\=\frac {Z_q}{Z_p} \int_x \hat g(x)q(x)dx\\\\其中，\hat g(x) = f(x)\frac {\hat g(x)}{\hat q(x)}=f(x)\hat w(x)$$而$\frac {Z_q}{Z_p}$直接计算不太好计算，而它的倒数：$$\frac {Z_p}{Z_q}=\frac {1}{Z_q}\int_x \hat p(x)dx, Z_q=\frac {\hat q(x)} {q(x)} $$所以：$$\frac {Z_p}{Z_q}=\frac {\hat p(x)}{\hat q(x)}q(x)dx = \int_x \hat w(x)q(x)dx$$这样，假设能方便从q(x)进行采样，所以上式又被转换为一个Monte Carlo可解的问题，也就是说：$$\frac {Z_p}{Z_q}=\frac {1}{m} \sum_{i=1}^m \hat w(x_i), x_i符合q(x)分布。$$最终，求解E[f(x)]的问题可以转换为：$$E[f(x)]=\frac {1}{m} \sum_{i=1}^m \hat w(x_i)f(x_i), 其中，x_i为符合q(x)的样本\\\ \hat w(x_i)=\frac {\hat w(x_i)}{\sum_{i=1}^m \hat w(x_i)}$$所以，我们可以在不用知道q(x)确切值的情况下，就可以近似地计算得到E[f(x)]。其计算过程如下：Importance Sampling采样过程： 首先为p(x)找到一个建议分布q(x),q(x)比较容易采样。 然后从q(x)中采样出m个点x 带入$E[f(x)] = \frac {1}{m} \sum_{i=1}^m \hat w(x_i)f(x_i)$ 计算期望。虽然这种方法能够work,但是在高维空间里找到一个这样合适的q(x)非常难。即使有 Adaptive importance sampling 和 Sampling-Importance-Resampling的出现，要找到一个同时满足容易抽样并且和目标分布相似的建议分布，通常是不可能的！ MCMC: Markov Chain Monte CarloImportance Sampling和Acceptance-Rejection Sampling虽然能够实现对一些分布的采样，但是只有当选取的建议分布q(x)和要进行采样的目标分布p(x)很近似时才表现好，所以选取合适的q(x)是非常关键。当在高维空间进行采样，标准的采样方法会失败，对于Acceptance-Rejection Sampling,当目标分布的维数增高时，拒绝率会趋近于100%，采样的效率会很低。对于Importance Sampling，大多数的样本的权重值会趋近于0。对于高维复杂问题，可以用马尔科夫链（Markov Chain)产生一系列相关样本，实现对目标分布的采样。MCMC是一种用一定范围内的均匀分布的随机数对高维空间概率进行采样的通用技术，其基本思想是设计一个马尔科夫链，使得其稳定概率分布为要采样的目标分布$\pi(x)$ 首先来看一下马尔科夫链的定义及其平稳分布： 马尔科夫性质：某一时刻状态转移的概率只依赖于它前一个状态 定义：假设存在状态序列$… X_{t-2},X_{t-1},X_t,X_{t+1}…$,时刻t+1的状态的条件概率只依赖于t时刻的状态$x_t$,即：$$P(X_{t+1}|…X_{t-2},X_{t-1},X_t)=P(X_{t+1}|X_t)$$ 马尔科夫链：满足马尔科夫性质的随机过程 以天气变化来解释一下上面的定义，假设每天的天气是一个状态的话，状态转移可以看成是天气的变化，比如从晴天变成阴天、从阴天变成雨天等。马尔科夫性质讲的是，今天的天气情况只依赖于昨天的天气，和前天以及之前的天气状况没有任何关系。马尔科夫链可以看成每天的天气按照这个规律进行变化的一个过程。一个马尔科夫链可以由下面的公式定义： 一个马尔科夫链一般由三部分构成： 状态空间：可以理解为天气状况的所有情况 {阴天，晴天，雨天，…} 初始状态：可以理解为第一天的天气情况 状态转移矩阵：可以理解为所有由一种天气状况变为另一种天气状况的概率 马尔科夫链具有一个非常重要的性质：马尔科夫链的平稳分布。来看一个例子，假设一个国家的人口地域分布分为：农村、城镇和城市3种状态。每年人口流动情况如下图： 上图表示每种状态转移到另一种状态的概率。如果定义矩阵P，P的某一位置P(i,j)的值为P(j|i)，表示从状态i转换为状态j的概率，则根据上图可以得到马尔科夫链的状态转移矩阵为： 假设初始状态的人口地域分布为$\pi_0=[\pi_0(1),\pi_0(2),\pi_0(3)]$，每年人口按照状态转移矩阵P进行转移，n年后人口的地域分布为$\pi_n=\pi_{n-1}P=…=\pi P^n$。假设存在如下两种初始的人口分布: $\pi_0=[0.5,0.4,0.1]$ $\pi_0=[0.3,0.4,0.3]$ 按照状态转移矩阵进行转移一定年数后的人口分布情况分布如下图所示： 可以看出，尽管采用了不同的初始化状态，但最终的概率分布都趋近于一个稳定的概率分布[0.167,0.388,0.444]。可以看到，马尔科夫链模型的状态转移矩阵收敛到稳定概率分布和初始状态概率分布无关。也就是说，如果得到了稳定概率分布对应的马尔科夫链模型的状态转移矩阵，我们可以从任意的概率分布样本开始，带入马尔科夫链模型的状态转移矩阵，经过一系列的状态转移，最终样本的分布会趋近于稳定的概率分布。用数学的语言来定义一下马尔科夫链的收敛性质：如果一个非周期的马尔科夫链，其状态转移矩阵为P，并且它的任何两个状态之间是联通的，那么$\lim_{n \rightarrow +\infty} P_{ij}^n$ 与i无关，则有： $\lim_{n \rightarrow +\infty} P^n = \begin{bmatrix}{\pi(1)}&amp;{\pi(2)}&amp;{\cdots}&amp;{\pi(n)}\\\\{\pi(1)}&amp;{\pi(2)}&amp;{\cdots}&amp;{\pi(n)}\\\\{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\\\{\pi(1)}&amp;{\pi(2)}&amp;{\cdots}&amp;{\pi(n)}\\\\\end{bmatrix}$ $\pi(j)=\sum_{i=0}^\infty P_{ij}$，$p_{ij}$表示状态i转移到状态j的概率 $\pi$是方程$\pi P = \pi$的唯一非负解，其中，$$\pi=[\pi(1),\pi(2),….,\pi(j),…] \sum_{i=0}^\infty \pi(i)=1$$ 上面的性质中有如下的说明： 非周期的马尔科夫链：主要是指马尔科夫链的状态转化不是循环的，如果是循环的则永远不会收敛。我们一般遇到的马尔科夫链一般都是非周期性的。用数学方式可以表述为：对于任意某一状态i,d为集合${n | n\geq 1,P_{ij}^n &gt; 0}$的最大公约数为1，如果d=1，则该状态为非周期的。 任何两个状态是联通的：指从任意一个状态可以通过有限步到达其他的任意一个状态，不会出现条件概率为0导致不可达的情况。 马尔科夫链的状态可以是有限的，也可以是无限的。因此，可以用于连续概率分布和离散概率分布。 $\pi$通常称为马尔科夫链的平稳分布。 基于马尔科夫链的采样方法从马尔科夫链的收敛性质可以看出，如果我们能够得到某个平稳分布对应的马尔科夫链状态转移矩阵，就很容易采样出这个平稳分布的样本。假设任意初始化的概率分布为$\pi_0(x)$，经过第一轮转移后的概率分布是$\pi_0(x)$，经过i轮后的概率分布为$\pi_i(x)$。假设经过n轮后马尔科夫链收敛到平稳分布$\pi(x)$,即：$$\pi_n(x)=\pi_{n+1}(x)=…=\pi(x)$$那么经过n轮之后的，沿着状态转移矩阵进行转移得到的样本都是符合$\pi(x)$分布的样本。也就是说，如果从一个具体的初始状态$x_0$出发，沿着马尔科夫链按照状态转移矩阵进行跳转，假设n次跳转后收敛，那么得到一个转移状态序列$X_0,X-1,…,X_n,X_{n+1},….$，则$X_n,X_{n+1},…$都是符合平稳分布$\pi(x)$的样本。 基于马尔科夫链的采样过程如下： 输入： 状态转移矩阵P，设定状态转移次数$n_1$，需要采样的样本个数$n_2$ 从任意概率分布采样得到一个初始状态值$x_0$ for t=0 to $n_1+n_2 - 1$：从条件概率分布$P(x|x_t)$中采样出样本为$x_{t+1}$ 输出：样本$(x_{n_1},x_{n_1+1},…,x_{n_1+n_2})$即为符合平稳分布$\pi(x)$的样本。 解释一下上面的从条件概率分布$P(x|x_t)$中采样出样本为$x_{t+1}$。为什么要从$P(x|x_t)$中进行采样？因为，当前的状态为$x_t$，从当前状态$x_t$进行转移，可转移到的状态为状态空间集合，所以要以当前状态为条件向其他状态进行转移，所以要从$P(x|x_t)$中进行采样。例如，人口分布的例子，假设当前的状态是农村，那么从农村转移到农村、城镇和城市的概率分别为0.5、0.4和0.1，即$P(x|x_t)=[0.5,0.4,0.1]$，转移时要按照这个分布进行转移，即采样时要按照这个分布进行采样，使用均匀分布可以很容易实现。而状态转移为连续的情况，则$P(x|x_t)$则是一个具体的连续分布，通过对$P(x|x_t)$的采样，实现转移。可以看出，我们要采样的目标分布为$\pi(x)$,如果我们能够构建一个状态转移矩阵P，使得其马氏链上的平稳分布是$\pi(x)$，那么初始化一个状态，按照状态转移矩阵P进行转移，经过n次后收敛，第n+1次后的样本都是符合$\pi(x)$分布的。所以，MCMC采样方法的关键是构建状态转移矩阵P。如何构建这个状态转移矩阵P呢？首先看一下马尔科夫链的细致平稳条件：如果一个非周期的马尔科夫链状态转移矩阵为P和概率分布$\pi(x)$，对于所有的i，j满足：$$\pi(i)P(i,j)=\pi(j)P(j,i)$$其中，P(i,j)表示状态i转移到状态j的概率,则称$\pi(x)$是状态转移矩阵P的平稳分布。证明：$$\sum_{i=1}^\infty \pi(i)P(i,j)=\sum_{i=1}^\infty \pi(j)P(j,i)=\pi(j)\sum_{i=1}^\infty P(j,i) = \pi(j)$$写成矩阵的形式，即：$$\pi P=\pi$$由于$\pi$是$\pi P=\pi$的解，所以$\pi$是一个平稳分布。上式被称为细致平稳条件(detailed balance condition)。其实这个定理是显而易见的，因为细致平稳条件的物理含义就是对于任何两个状态i,j 从i转移出去到j而丢失的概率质量，恰好会被从j转移回i的概率质量补充回来，所以状态i上的概率质量$\pi(i)$是稳定的，从而$\pi(x)$是马尔科夫链的平稳分布。从细致平稳条件可以看出，只要找到可以使概率分布$\pi(x)$满足细致平稳分布的矩阵P即可。假设在进行采样之前已经存在一个状态转移矩阵Q，Q(i,j)表示从状态i转移到状态q的概率，也可以表示为Q(j|i),通常情况下：$$\pi(i)Q(i,j)\neq \pi(j)Q(j,i)$$也就是说不满足细致平稳条件。不过可以对其进行改造，使其满足细致平稳条件。具体的是引入$\alpha$使得上面的公式成立，即：$$\pi(i)Q(i,j)\alpha(i,j)=\pi(j)Q(j,i)\alpha(j,i)$$什么样的$\alpha$能够使上式成立呢？最简单的，按照对称性，可以取如下的值：$$\alpha(i,j)=\pi(j)Q(j,i)\\\\\alpha(j,i)=\pi(i)Q(j,i)$$在改造Q的过程中，引入的$\alpha(i,j)$称为接受率，取值在[0,1]之间，物理意义可以理解为在原来的马尔科夫链上，从状态i以Q(i,j)的概率转跳转到状态j的时候，我们以$\alpha(i,j)$的概率接受这个转移。这样就可以得到新的马尔科夫链的转移概率为$Q(i,j)\alpha(i,j)$。通过这种改造，就能够进行采样了。MCMC采样过程如下：MCMC采样算法 初始化马尔科夫链初始状态$X_0=x_0$ fo t=0,1,2,… do:2.1 在t时刻马尔科夫链状态为$X_t=x_t$，从$Q(x|x_t)$中采样出一个样本y2.2 从均匀分布中采样出u~Uniform(0,1)2.3 如果$u&lt;\alpha(x_t,y)=\pi(y)Q(x_t|y)$，则接受转移$x_{t+1}=y$2.4 否则，不接受转移，$x_{t+1}=x_t$ 上面的MCMC采样算法已经能够很好的工作了，但是它存在一个缺陷:马氏链在转移的过程中的接受率$\alpha(i,j)$可能偏小，这样采样过程中，马氏链不容易转移，一直处于原地，导致收敛到平稳分布的速度偏慢。假设$\alpha(i,j)=0.1,\alpha(j,i)=0.2$，假设在此时满足细致平稳条件，于是有：$$\pi(i)Q(i,j).0.1 = \pi(j)\alpha(j,i).0.2$$将上式两边同时扩大5倍，等式变为：$$\pi(i)Q(i,j).0.5 = \pi(j)\alpha(j,i).1$$可以看到细致平稳条件并没有被打破，而接受率变大了。因此，我们可以把细致平稳条件中的$\alpha(i,j)$和$\alpha(j,i)$同比例放大，使得两个数中较大的那个放大到1，这样就提高了采样中的跳转的接受率。于是$\alpha(i,j)$可以取下面的值:$$\alpha(i,j) = min{\frac {\pi(j)Q(j,i)} {\pi(i)Q(i,j)},1}$$这样，就完成了对MCMC采样算法的改造，这就是Metropolis-Hastings采样算法，其采样过程如下：Metropolis-Hastings采样算法 初始化马尔科夫链初始状态$X_0=x_0$ for t=0,1,2,… do:2.1 在t时刻马尔科夫链状态为$X_t=x_t$，从$Q(x|x_t)$中采样出一个样本y2.2 从均匀分布中采样出u~Uniform(0,1)2.3 如果$u&lt;\alpha(x_t,y)=min{\frac {\pi(y)Q(y,x_t)} {\pi(x_t)Q(x_t,y)},1}$，则接受转移$x_{t+1}=y$2.4 否则，不接受转移，$x_{t+1}=x_t$ Gibbs Sampling虽然MCMC采样和Metropolis-Hasting采样算法已经能够解决蒙特卡罗方法中需要的任意概率分布的样本的问题。但是还是存在一定的缺陷，首先是采样过程中要计算接受率，在高维时，计算量大，可能存在辛辛苦苦计算出的接受率，最终被拒绝，不跳转。并且由于接受率的原因导致算法的收敛时间变长。其次是，对于高维空间，状态的条件概率分布好求解，但是联合分布不好求。针对这一问题，对于高维空间的数据采样，Stuart Geman和Donald Geman这两兄弟于1984年提出来了Gibbs Sampling算法。Gibbs Sampling算法思想是通过构建状态转移矩阵，使得接受率为1，从而提升了接受的效率。对于二维情形，假设存在一个概率分布P(x,y)，对于x坐标相同的两个点$A(x_1,y_1),B(x_1,y_2)$可以得到如下公式：$$p(x_1,y_1)p(y_2|x_1) = p(x_1)p(y_1|x_1)p(y_2|x_1)\\\\p(x_1,y2)p(y_1|x_1)=p(x_1)p(y_2|x_1)p(y_1|x_1)$$上面的转换是利用乘法公式进行转换的。于是可以得到：$$p(x_1,y_1)p(y_2|x_1) = p(x_1,y_2)p(y_1,x_1)\\\\p(A)p(y_2|x_1) = p(B)p(y_1|x_1)$$可以看到，在$x=x_1$这条直线上，如果使用条件概率分布$p(y|x_1)$作为任意两点转移概率，那么任何两点之间的转移概率满足细致平稳条件。同样，在$y=y_1$这条直线上任取两点$A(x_1,y_1),C(x_2,y_1)$，同样有：$$p(A)p(x_2|y_1)=p(C)p(x_1|y_1)$$于是可以构造平面上任意两点之间的转移概率矩阵Q:$$Q(A-&gt;B)=p(y_B|x_1), if x_A=x_B=x_1\\\\Q(A-&gt;C)=P(x_C|y_1), if y_A=y_C=y_1\\\\Q(A-&gt;D)=0，其他$$则对于平面上任意两点X,Y,很容易验证是否满足细致平稳条件：$$p(X)Q(X-&gt;Y)=P(Y)Q(Y-&gt;X)$$于是二维的Gibbs Sampling采样算法，采样过程如下： 随机初始化$X_0=x_0, Y_0=y_0$ 对于t=1,2,…循环采样：2.1 从条件概率分布$p(y|x_0)$中采样得到$y_1$2.2 从条件概率分布$p(x|y_1)$中采样得到$x_1$ 对于多维的情况，算法也是成立的。例如，一个n维的概率分布$\pi(x_1,x_2,…,x_n)$，可以通过在n个坐标轴上轮换进行采样，得到新的样本集。对于轮换到的任意一个坐标轴$x_i$上的转移，马尔科夫链的状态转移概率为$p(x_i|x_1,x_2,…,x_{i-1},x_{i+1},…,x_n)$。即固定n-1个坐标轴，在某一个坐标轴上移动，同样是满足细致平稳条件。多维的Gibbs Sampling算法采样过程如下： 随机初始化${x_i:i=1,…,n}$ 对于t=0,1,2,…循环采样：2.1 $X_{1}^{t+1} ~p(x_1|x_{2}^{(t)},x_{3}^{(t)},…,x_n^{(t)}$2.2 $X_{2}^{t+1} ~p(x_2|x_{1}^{(t+1)},x_{3}^{(t)},…,x_n^{(t)}$2.3 …2.4 $X_{j}^{t+1} ~p(x_j|x_{1}^{(t+1)},x_{2}^{(t+1)},…,x_{j-1}^{(t+1)},x_{j+1}^{(t)},…,x_n^{(t)}$2.5 …2.5 $X_{n}^{t+1} ~p(x_1|x_{1}^{(t+1)},x_{2}^{(t+1)},…,x_{n-1}^{(t+1)}$ 同样的，轮换坐标轴不是必须的，可以随机选择某一个坐标轴进行状态转移，只不过常用的Gibbs采样的实现都是基于坐标轴轮换的。 Reference Pattern Recognition and Machine Learning， Christopher Bishop，Chapter 11 LDA数学八卦 http://blog.csdn.net/dark_scope/article/details/70992266 http://www.cnblogs.com/pinard/p/6625739.html https://cosx.org/2013/01/lda-math-mcmc-and-gibbs-sampling http://www.jdl.ac.cn/user/lyqing/StatLearning/10_08_MonteCarlo-blue.pdf http://www.jdl.ac.cn/user/lyqing/StatLearning/10_13_MonteCarlo2.pdf]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Sampling Methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写可读代码的艺术-读书笔记]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第二章 把信息装到名字里​ 主题是：把信息塞入名字中。即，读者仅通过读到名字就可以获得大量的信息。主要有以下几点： 使用专业的单词–例如，不用Get，而用Fetch或者Download可能会更好，这由上下文决定。 避免空泛的名字，像tmp和retval，除非使用它们有特殊的理由。 使用具体的名字来更细致地描述事物——ServerCanStart() 这个名字就比CanListenOnPort更不清楚。 给变量名带上重要的细节——例如，在值为毫秒的变量后加上_ms，或者在还需要转义的、未处理的变量前加上raw_。 为作用域大的名字采用更长的名字——不要用让人费解的一个或两个字母的名字来命名在几屏之间都可见的变量。对于只存在于几行之间的变量用短一点的名字更好。 有目的地使用大小写、下划线等——例如，可以在类成员和局部变量后面加上“_”来区分它们。第三章 不会误解的名字​ 不要误解的名字是最好的名字——阅读你代码的人应该理解你的本意，并且不会有其他的理解。 在决定使用一个名字以前，要想象一下你的名字被误解成什么。最好的名字是不会误解的。 当要定义一个值的上限或下限时，max_和min_是很好的前缀。对弈包含的范围，first和last是好的选择。对于包含/排除范围，begin和end是好的选择。 当为布尔值命名时，使用is和has这样的词来明确表示它是一个布尔值，避免使用反义的词。 要小心用户对特定词的期望。例如，用户会期望get()或者size()是轻量的方法。第四章 审美​ 通过把代码用一致的、有意义的方式“格式化”，可以把代码变得更容易读，并且可以读得更快。下面是讨论过的一些具体技巧: 如果多个代码块做相似的事情，尝试让他们有同样的剪影。 把代码按“列”对齐可以让代码更容易浏览。 如果在一段代码中提到A、B和C，那么不要在另一段中说B、C和A。选择一个有意义的顺序，并始终用这样的顺序。 用空行来把大块分成逻辑上的“段落”。第五章 该写出什么样的注释 注释的目的是帮助读者了解作者在写代码时已经知道的那些事情。本章主要介绍如何发现所有的不那么明显的信息块并把它们写下来。什么地方不需要注释: 能从代码本身中迅速地推断的事实。 用来粉饰烂代码的“拐杖式注释”——应该把代码改好。应该记录下来的想法包括: 对于为什么代码写成这样而不是那样的内在理由（“指导性批注”）。 代码中的缺陷，使用像TODO:或者XXX:这样的标记。（TODO:还没有处理的事情；FIXME：已知的无法运行的代码；HACK：对一个问题不得不采用的比较粗暴的解决方案；XXX：危险！这里有重要的问题） 常量背后的故事，为什么是这个值。站在读者的立场上思考: 预料到代码中哪些部分会让读者产生疑问，并且给它们加上注释。 为普通读者意料之外的行为加上注释。 在文件/类的级别上使用“全局观”注释来解释所有的部分是如何一起工作的。 用注释来总结代码块，使读者不致迷失在细节中。第六章 如何写出言简意赅的注释 当像“it”和“this”这样的代词可能指代多个事物时，避免使用它们。 尽量精确地描述函数的行为。 在注释中用精心挑选的输入/输出例子进行说明。 声明代码的高层次意图，而非明显的细节。 用嵌入的注释来解释难以理解的函数参数。 用含义丰富的词来使注释简洁。第七章 把控制流变得易读有几种方法可以让代码的控制流更易读 在写一个比较时（while （bytes_expected &gt; bytes_received）），把改变的值写在左边，并且把更稳定的值写在右边更好一些（while （bytes_received &lt; bytes_expected））。 可以重新排列if/else语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时这种准则会冲突，但是当不冲突时，这是要遵守的经验法则。 某些编程结构，像三目运算符(:?)、do/while循环，以及goto经常会导致代码的可读性变差。最好不要使用它们，因为总是有更整洁的代替方式。 嵌套的代码块需要更加集中精力去理解。每层新的嵌套都需要读者把更多的上下文“压入栈”。应该把它们改写成更加“线性”的代码来避免深嵌套。 通常来讲提早返回可以减少嵌套并让代码整洁。“保护语句”（在函数顶部处理简单的情况时）尤其有用。第八章 拆分超长的表达式 关键思想：把超长的表达式拆分为更容易理解的小块 引入“解释变量”来代表较长的子表达式。这种方式有三个好处： 它把巨大的表达式拆成小段； 它通过用简单的名字描述子表达式来让代码文档化； 它帮助读者识别代码中的主要概念。 用德摩根定理来操作逻辑表达式——这个技术可以把布尔表达式用更整洁的方式重写； 任何复杂逻辑的地方都可以进行拆分。第九章 变量与可读性减少变量 删除没有价值的临时变量 减少中间结果 减少控制变量缩小变量的作用域 关键思想:让你的变量对尽量少的代码行可见。 只写一次的变量更好总结 本章是关于程序中的变量是如何快速累积而变得难以跟踪的。你可以通过减少变量的数量和让它们尽量“轻量级”来让代码更有可读性。具体有： 减少变量。 减少每个变量的作用域，越小越好。把变量移到一个有最少代码可以看到的地方。 只写一次的变量更好。那些只设置一次的变量（或者const、final、常量）使得代码更容易理解。第十章 抽取不相关的子问题​ 本章一个简单的总结就是“把一般代码和项目专有的代码分开“。其结果是，大部分的代码都是一般代码。通过建立一大组库和辅助函数来解决一般问题，剩下的只是让你的程序与众不同的核心部分。​ 这个技巧有帮助的原因是它使程序员关注小而定义良好的问题，这些问题已经同项目的其他部分脱离。其结果是，对于这些子问题的解决方案倾向于更加完整和正确。你也可以再以后重用它们。第十一章 一次只做一件事 关键思想：应该把代码组织得一次只做一件事情 ​ 如果你有很难读的代码，尝试把它所做的所有任务列出来。其中一些任务可以很容易地变成单独的函数。其他的可以简单地变成为一个函数中的逻辑”段落”。具体如何拆分这些任务没有它们已经分开这个事实那样重要。难的是要准确地面描述你的程序所做的所有这些小事情。 第十二章 把想法变成代码​ 本章讨论了一个简单的技巧，用自然语言描述程序然后用这个描述来帮助你写出更自然的代码。这个技巧出人意料地简单，但很强大。看到你在描述中所用的词和短语还可以帮助你发现哪些子问题可以拆分出来。但是这个“用自然语言说事情”的过程不仅可以用于写代码。另一个看待这个问题的角度是：如果你不能把问题说明白或者用词语来做设计，估计是缺少什么东西或者什么东西缺少定义。把一个我那天变成语言可以让它变得更具体。 第十三章 少写代码 关键思想:最好的代码就是没有代码。 质疑和拆分你的需求 保持小的代码库 ​ 随着项目的增长，项目加进来的越来越多的源文件。项目很大，没有一个人自己全部理解它。增加新功能会变得很痛苦，而且使用这些代码还很费力还令人不快。最好的解决办法就是”让你的代码库越小，越轻量级越好“，可以尝试如下方法： 1. 创建越多越好的”工具“代码来减少重复代码； 2. 减少无用代码或没用的功能； 3. 让你的项目保持分开的子项目状态； 4. 总的来说，要小心代码的”重量“。让它保持又轻又灵。 熟悉你周边的库 总结 ​ 本章是关于写越少代码越好的。每行新的代码都需要测试、写文档和维护。另外，代码库中的代码越多，它就越”重“，而且在其上开发就越难。可以通过以下方法来避免重新编写新代码： 从项目中消除不必要的功能，不要过度设计； 重新考虑需求，解决版本最简单的问题，只要能完成工作就行； 经常性地通读标准库的整个API，保持对他们的熟悉程度。 第十四章 测试与可读性在测试代码中，可读性仍然很重要。如果测试的可读性很好，其结果是他们也会变得很容易写，因此大家会写更多的测试。并且，如果你把事实代码设计得容易测试，代码设计会变得更好。以下是如何改进测试的具体要点： 每个测试的最高一次应该越简明越好。最好每个测试的输入/输出可以用一行代码描述； 如果测试失败了，它所发出的错误消息应该能让你容易跟踪并修正这个bug； 使用最简单的并且能够完整运用代码的测试输入； 给测试函数取一个有完整描述性的名字，以使每个测试所测到的东西很明确。不要用Test1()，而要像Test___这样的名字。 最重要的是，要使它易于改动和增加新的测试。]]></content>
      <categories>
        <category>程序猿的自我修养</category>
      </categories>
      <tags>
        <tag>程序猿的自我修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 类]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC7%E7%AB%A0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[7.1 定义抽象数据类型构造函数 每个类都分别定义了它的对象初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。构造函数的名字和类名相同，和其他函数不一样的是，构造函数没有返回类型；除此之外类似于其他的函数，构造函数也有一个参数列表和一个函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。 不同于其他成员函数，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。 默认构造函数 类通过一个特殊的构造函数来控制默认初始化的过程，这个函数叫做默认构造函数。默认构造函数无须任何实参。如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数。对于大多数来说，这个合成的默认构造函数按照如下规则初始化类的数据成员： 如果存在类内的初始化值，用它类初始化成员。 否则，默认初始化该成员。 某些类不能依赖于合成的默认构造函数 合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义它自己的默认构造函数。其原因如下： 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。 对于某些类来说，合成的默认构造函数可能执行错误的操作。 有时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类，我们必须要自定义默认构造函数，否则该类将没有可用的默认构造函数。 构造函数初始值列表如果编译器不支持内置初始值，那么默认的构造函数就应该使用构造函数初始值列表来初始化类的每个成员。例如，12Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125;Sales_data(const std::string &amp;s, unsigned n, double p):bookNo(s),units_sold(n), revenue(p*n) &#123;&#125; 我们把括号里的部分称为构造函数初始值列表，它负责为新创建的对象的一个或几个数据成员赋值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值。不同成员的初始化通过逗号分隔开来。 通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予一个正确的值。不过如果编译器不支持类内初始值，则所有的构造函数都应该显式地初始化每个内置类型的成员。 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。 7.2 访问控制与封装在C++语言中，我们使用访问说明符加强类的封装性： 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。 使用class和struct定义类的唯一区别就是默认的访问权限。 7.2.1 友元类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元。如果想把一个函数作为它的友元，只需增加一条以friend关键字开始的函数声明语句即可：12345678910class Sales_data&#123;//为Sales_data的非成员函数所做的友元声明 friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp; ); friend std::ostream &amp;print(std::ostream&amp; ,const Sales_data&amp;); public： //... private: //...&#125; 友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。一般来说，最好在类定义开始或结束前的位置集中声明友元。 封装的益处 封装有两个重要的优点： 确保用户代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 7.3 类的其他特性可变数据成员 有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员永远不会是const，即使它是const对象成员。因此，一个const成员函数可以改变一个可变成员的值。例如：12345678910class Screen&#123; public: void some_member() const; private: mutable size_t access_ctr; //即使在一个const对象内也能被修改&#125;void Screen::some_member() const&#123; ++access_ctr; //保存一个计数值，用于记录成员函数被调用的次数&#125; 尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。 类类型每个类定义了唯一的类型，对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。对于一个类来说，它的成员和其他任何类的成员都不是一回事。就像可以把函数的声明和定义分离开来一样，我们也能仅声明类而暂时不定义它：1class Screen; //Screen类的声明 这种声明有时被称作前向声明，它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型，也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明以不完全类型作为参数或者返回类型的函数。对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。 7.3.4 友元再探类之间的友元关系 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。必须要注意的一点是，友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。 令成员函数作为友元 除了令整个windo_mgr作为友元之外，Screen还可以只为clear挺访问权限。当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类：1234class Screen&#123;//Window_mgr::clear必须在Screen类之前被声明 friend void Window_mrg::clear(ScreenIndex);&#125; 要想令某个成员函数作为友元，我们必须仔细组织程序的结构，以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序： 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员函数之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明。 最后定义clear，此时它才可以使用Screen的成员。 7.4 类的作用域每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。不论哪种情况，跟在运算符之后的名字都必须是对应类的成员。 名字查找与类的作用域在编写的程序中，名字查找（寻找与所用名字最匹配的声明的过程）的过程比较直接了当： 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。 如果没有找到，继续查找外层作用域。 如果最终没有找到匹配的声明，则程序报错。 对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的例子中体现的不太明显。类的定义分为两步处理： 首选，编译成员的声明。 直到类全部可见后才编译函数体。 一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而，在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能再之后重新定义改名字。 成员定义中普通块作用域的名字查找成员函数中使用的名字按照如下方式解析： 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 如果在成员函数内没有找到，则在类内进行查找，这时类的所有成员都可以被考虑。 如果类内也没有找到该名字的声明，在成员函数定义之前的作用域内继续查找。 7.5 构造函数再探 如果成员是const、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。 成员函数的初始化顺序 成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。 一般来说，初始化的顺序没有什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。 默认实参和构造函数 如果一个构造函数为所有的参数都提供了默认实参，则它实际上也定义了默认构造函数。 委托构造函数 C++11新标准扩展了构造函数的初始值的功能，使得我们可以定义所谓的委托构造函数。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。举个例子： 1234567891011class Sales_data&#123; public: //非委托构造函数使用对应的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price): bookNo(s),units_sold(cnt),revenue(cnt* price)&#123;&#125; //其余构造函数全都委托给另一个构造函数 Sales_data():Sales_data("", 0 , 0) &#123;&#125; Sales_data(std::string a):Sales_data(s, 0, 0)&#123;&#125; Sales_data(std::istream &amp;is):Sales_data()&#123; reda(is, *this);&#125;&#125; 在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作给另一个函数。 默认构造函数的作用 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生： 当我们在块作用域内不是要任何初始值定义一个非静态变量或者数组时。 当一个类本身含有类类型的成员且使用合成的默认构造函数时。 当类类型的成员没有在构造函数初始值列表中显示地初始化时。 值初始化在以下情况发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。 当我们不使用初始值定义一个局部静态变量时。 当我们通过书写形如T()的表达式显式地请求值初始化时，其中T是类型名。 类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。 隐式的类类型转换 抑制构造函数定义的隐式转换，在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止。explicit构造函数只能用于直接初始化。发生隐式转换的一种情况是当我们执行拷贝形式的初始化时，此时我们只能使用直接初始化而不能使用explicit构造函数。 聚合类聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的： 所有的成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类，也没有virtual函数。 7.6 类的静态成员声明静态成员 我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。举个例子：1234567891011class Account&#123; public: void calculate()&#123; amount += amount * interestrate;&#125; static double rate() &#123; return interestrate;&#125; static void rate(double); private: std::string owner; double amount; static double interestrate; static double initRate();&#125;; 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有的Account对象共享。 静态成员不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明为const的，而且我们也不能再static函数体内使用this指针。 定义静态成员 和其他成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只能出现在类内部的声明语句：1234void Account::rate(double newRate)&#123; interestRate = newRate;&#125; 一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。类似全局变量，静态数据成员定义在任何函数之外。因此，一旦它被定义，就将一直存在于程序的整个生命周期中。 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。 静态成员的类内初始化 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态成员指定数组成员的维度：12345678class Account&#123; public: static double rate() &#123;return interestRate;&#125; static void rate(double); private: static constexpr int period = 30; //period是常量表达式 double daily_tbl[period];&#125; 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static 不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须要有一条定义语句。 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vi编辑器使用]]></title>
    <url>%2F2017%2F10%2F10%2FVi%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、vi编辑器概述1.1 启动vi编辑器启动vi编辑器的方式如下： 命令 说明 vi filename，vim filename 从filename文件的第1行开始编辑，即光标默认停留在文件的第1行第一个字符处。 vi/vim + n filename 从filename文件的第n行开始编辑，即光标默认停留在文件的第n行的第一个字符处 vi/vim + filename 从filename文件的最后1行开始编辑，即光标默认停留在文件的最后一行第一个字符处。 vi/vim +/.pattern filename 从filename文件的第1行包含字符串“pattern”的行开始编辑 vi/vim -r filename 在系统崩溃后恢复filename vi/vim -R filename 以只读的方式编辑filename 当用vim打开并编辑一个文件时，该文件会被自动锁定。如果此时另一用户也希望打开该文件进行编辑将会出现一些提醒： 以只读方式打开文件：按字母键o，用户以只读方式打开文件，不会影响其他用户对该文件的同时操作。 直接编辑：按字母键e，可以直接编辑该文件，但与其他同时操作的文件的用户在存盘时可能会冲突。 恢复：按字母键r。如果出现在该界面是由上一次编辑此文件时崩溃引起的，选择该选项可以恢复修改内容。 退出：按字母键q，直接退出vi编辑器。 1.2退出vi退出vi可按下Esc键，然后输入q即可退出vi，返回Shell提示符。 1.3 命令模式用户可以输入命令，通过命令实现移动光标、删除或修改部分文本以及如复制、粘贴、退出等操作。命令一经输入就立即执行，不需要按回车键。不管在什么模式下，只要按一下Esc键，即可将vi切换到命令模式下： 命令 说明 i 在当前字符前插入文本 I 在当前行的行首插入文本 a 在当前字符之后追加文本 A 在当前行的行尾追加文本 o 在当前行的下面添加一新行 O 在当前行的上面添加一新行 1.4 末行模式在命令模式下按下冒号键即可切换到末行模式。此时光标停留在最后一行上，并等待用户输入所需执行的末行命令。当用户输入命令后，按回车键，命令即可被执行。例如，输入命令set number并按回车键后，使得光标跳到指定的行。 1.2 vi中常用命令1.2.1 插入命令：i和I1.2.2 附加文本命令：a和A1.2.3 字符与块删除命令在命令行模式下，删除命令分两种，一种是字符删除命令，一种是块删除命令删除字符使用x/X命令，x命令可以删除当前字符，X命令可以删除当前光标左侧字符。如果在使用命令前指定了重复的次数，可连续删除多个字符。例如，命令3w表示删除从当前光标位置开始向后的3个字符，命令3W表示删除当前光标之前的3个字符。命令d/D可以把指定的文本块从工作缓冲区中删除。命令D表示删除从当前光标开始到本行未尾一段字符。命令d还需配合其他命令组合来确定删除文本块的大小。具体的使用如下： 命令 说明 x 删除当前字符 X 删除当前光标左侧字符 dl 与命令x相同 d0 从行的开始处删除 d$ 或 D 删除到行的末尾 dw 删除到单词的末尾 d) 删除到句子末尾 dd 删除一行 dL 删除到当前屏幕的最后一行（包括最后一行） 3dd 删除当前行开始的3 dH 从当前屏幕的第1行开始删除 1.2.4 行合并命令：J在命令行模式 下，合并命令可将当前行的末尾与下一行连接起来，并在两行之间插入一个空格，合并后光标定位到该空格处。如果当前行以句号结束，则会在两行之间插入两个空格。 1.2.5 文本替换命名在命令行模式下，替换命令s/S可以删除指定的文本，并使vi进行插入模式。命令s只替换当前字符，即删除当前光标所在位置的字符并切换到插入模式。命令S与命令cc类似，可以删除当前行并切换到插入模式。编辑完文本后，按esc键可以切换到命令模式，完成替换操作。在命令s前加入数字可以指定要替换字符的数目。例如，3s表示删除从当前光标所在字符开始的3个字符，并且切换到插入模式。如果指定的数目超出了当前行的行尾，则删除到行尾结束。 1.2.6 句点命令在命令行模式下，句点命令将重复执行最近一次的修改命令。例如，如果刚刚用命令dd删除了当前一行，那么命令.将会继续删除接下来的一行。 1.2.7 撤销修改命令：u/Uvi包括一个通用缓冲区和26个命名缓冲区，vi会将最近的修改保存在通用缓冲区中，撤销命令实际上是从通用缓冲区取出文本并进行恢复操作。在编辑修改文本之后，在命令行模式下直接使用撤销命令可以恢复到文本修改之前的状态。撤销修改命令包括u和U命令命令u可以撤销上一次的编辑操作。执行一次u命令只能撤销上一次对文本的操作。如果删除一行后又插入了某些字符，则执行一次u命令只能删除插入的字符。如果希望恢复删除的行，则需要再执行一次u命令。命令U可以撤销当前的所有修改，将文本恢复到启动修改之前的状态。 1.2.8 复制命令：y/Y赋值命令实际是把指定的文本内容复制到通用缓冲区。复制命令包括y和Y命令，需要在命令模式下使用。命令yy可以复制一行，默认是当前行。如果需要复制多行，可以在命令yy前指定行数，例如3yy可以复制当前开始的3行文本。命令Y与yy类似。 1.2.9 粘贴命令：p/P命令p把通用缓冲区的内容插入到当前字符之后。命令P把通用缓冲区的内容插入到当前字符之前。 1.2.10 重复执行 ctrl+r如果撤销某个命令后又想重新执行该命令，可以在命令模式下使用组合键Ctrl+R，也可以在末行模式下输入命令：redo并按回车键，vi会重新执行已被撤销的命令。重复命令也可以连续执行多次。 1.3 vi中字符与文件操作vi可以在整个缓冲区查找与正则表达式匹配的字符串。在命令模式下，键入斜杠(/)后跟待查找的字符串，按回车键，vi即可开始搜索。状态行将同步显示插入的斜杠和搜索字符串。如果搜索成功，光标会停留在首次匹配该字符串的第1个字符处。按n键可以向后重复上一次搜索，按N键可以向前重复上次的搜索。 1.3.1 查找指定字符命令在命令行模式下，命令f可以在当前行当前光标出开始查找指定的字符，并将光标移动到该字符出现的位置。如果没有找到，则不移动光标。F命令与f类似，只是在本行开始的位置到光标所在位置之间查找。 命令t在查找字符时，会将光标定位在指定字符出现位置前一个字符位置，而命令T在查找字符时会将光标定位在指定字符出现的后一字符位置。 1.3.2 替换指定字符串在末行模式下的替换命令s具有查找和修改功能。替换命令首先查找某个字符串，然后修改该字符串。末行模式下的替换命令s语法格式如下：1:[g] [address] s/ search/replacement [/option] 其中，g表示在所有的行进行查找和替换，否则只对第一次查找的结果进行替换。address表示查找的范围，如果不指定address，默认只搜索当前行。search表示搜索的字符串，replace表示替换字符串，/为分隔符。 分隔符可以使用除字母、数字、空白符和反斜杠之外的任意其他字符，但应保持search前后的分隔符相同。 address示例 说明 3 第3行 22,100 从22行到100行之间，包括22行和100行 5, . 从第5行开始至当前行 5,$ 从第5行值末尾 % 整个缓冲区 g/pattern 包含字符串pattern的所有行 /pattern/ 搜索到首次包含字符串pattern 的行 .,. +20 从当前行开始向后的连续20行 .,. -10 从当前行开始向前的连续10行 命令 说明 :s/string1/string2 将当前行中第1次搜索到的字符串string1替换为string2 :1,.s/string1/string2/g 将当前行之前的所有行中的字符串string1替换为string2，其中g表示在每一行中都允许进行多次替换 :1,$s/string1/string2/g 将所有的行中出现字符串string1替换为string2 :%s/string1/string2/g 将所有的行中出现字符串string1替换为string2 :.,.+10s/string1/string2/g 将从当前行开始连续10行内出现的字符串string1替换为string2 :/string/s/string1/string2/g 将首次串string的行中字符串string1替换为string2 :g /string/s/string1/string2 在所有行中将包含string字符串的行中的第一次出现string1的字符串替换为string2 :g /string/s/string1/string2/g 在所有行中将包含string字符串的行中的string1的字符串替换为string2 5,.s/string1/string2 将第5行到当前行之间所有行中出现的string1替换为string2 1.3.3 更改大小写的命令在命令模式下，代字符（~）可以用来更改字母的大小写，可以将小写字母改为大写，也可以将大写字母改为小写。 1.3.4 定位到指定行命令在命令模式下，输入命令“行号+G”可以将当前光标定位到缓冲区中指定的行， 如果没有指定行号，默认将光标定位到缓冲区的最后一行。命令G不需要缓冲区显式地给出行号，即即使不显示行号，也可以定位到指定的行。例如，在命令行模式下，输入3G可以将光标定位到缓冲区第3行。 1.3.5 显示状态信息命令显示文件状态信息通常有 两种方式：在命令模式下，按ctrl+G组合键和在末行模式下使用命令f 1.3.6 保存和退出命令 命令 说明 :w 保存缓冲区，但不退出。保存后磁盘中的文件被修改，不能恢复 :w filename 将缓冲区的内容保存到指定的filename中 ZZ 保存并退出，在命令下使用 :q 退出，但如果缓冲区已经被修改将提示错误信息，不能退出 :wq 保存并退出 q! 直接退出，系统不进行警告 1.4 窗口操作1.4.1 窗口操作的快捷方式 组合键ctrl+W+S：用于打开编辑同一个文件的另一个窗口，即用于实现窗口的水平切分。 组合键ctrl+W+N：可以用于打开一个新的窗口编辑一个新的文件。 组合键Ctrl+W+W：可以实现多个窗口之间的切换。 1.4.2 窗口垂直拆分：vsplit1.4.3 窗口水平拆分：split1.4.4 屏幕滚动当一个文件的行数超出了屏幕所能显示的最大行数时，需要上下滚动文本才能观察到全部内容。滚动的方向是相对文本而言的，不是相对屏幕。向下滚动意味着向文件的结尾处移动。具体滚动命令如下： 命令 说明 ctrl+Y 向上滚动一行 ctrl+E 向下滚动一行 ctrl+U 向上滚动半屏 ctrl+D 向下滚动半屏 ctrl+F 向下滚动整屏 ctrl+B 向上滚动整屏]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第13章 拷贝控制]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC13%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本章主要学习类如何控制该类型对象拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数控制这些操作，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。 当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五中特殊的成员函数来控制这些操作。包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。拷贝和移动构造函数定义了当用同类型的同一个对象初始化对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。 13.1 拷贝、赋值与销毁13.1.1 拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。123456class Foo&#123; public: Foo(); //默认构造函数 Foo(const Foo&amp;); //拷贝构造函数&#125; 拷贝构造函数的第一个参数必须是一个引用类型。拷贝构造函数通常不应该是explicit的。 合成拷贝构造函数 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。 对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。 每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。 拷贝初始化12345string dots(10,'.'); //直接初始化string s(dots); //直接初始化string s2 = dots; //拷贝初始化string null_book = "9-9999-9999";//拷贝初始化 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。 拷贝初始化发生的情况 使用=号定义变量时。 将一个对象作为实参传递给一个非引用类型的实参。 用花括号列表初始化一个数组中的元素或一个聚合类的成员。 参数和返回值 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功-为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。 13.1.2 拷贝赋值运算符与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。 13.1.3 析构函数在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照他们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后按照成员初始化顺序的逆序销毁成员。 什么时候会调用析构函数无论何时一个对象被销毁，就会自动调用其析构函数： 变量在离开其作用域时被销毁。 当一个对象被销毁时，其成员被销毁。 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。 对于临时对象，当创建它的完整表达式结束时被销毁。 由于析构函数自动运行，我们的程序可以按需分配需要的资源，而无须担心何时释放这些资源。 13.1.5 使用=default我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。123456789class Sales_data&#123; public: //拷贝控制成员：使用default Sales_data() = default; Sales_data(const Sales_data &amp;) = default; Sales_data&amp; operator =(const Sales_data &amp;); ~Sales_data() = default; //其他成员的定义，&#125; 当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。 13.1.6 阻止拷贝 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式还是显式地。 虽然，大多数的类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。 定义删除的函数 在新的标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的列表后面加上=delete来指出我们希望它地定义为删除的。12345struct NoCopy&#123; NoCopy() = default; //使用合成的默认构造函数 NoCopy(const NoCopy&amp;)=delete; //阻止拷贝 NoCopy &amp;operator=(const NoCopy&amp;) = delete;//阻止赋值&#125; =delete通知编译器，我们不需要定义这些成员。 与default不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此=default直到编译器生成代码时才需要。另一方面，编译器需要直到一个函数是删除的，以便禁止试图使用它的操作。 与=defalut的另外一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。 析构函数不能是删除的成员 合成的拷贝控制成员可能是删除的如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似地，如果一个类未定义构造函数，编译器会为其合成一个默认的构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数： 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。 如果类的某个成员的拷贝赋值运算符时删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。 如果类的某个成员的析构函数是删除的或不可访问的，或是有一个引用成员，它没有类内初始化器、或是类有一个const成员，它没有类初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。 本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。 13.2 拷贝控制和资源管理通常管理类外资源的类必须定义拷贝控制成员。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝的操作，使类的行为看起来像一个值或像一个指针。 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象的时候，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。 行为像指针的类则共享状态。当我们拷贝一个这类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。 13.3 交换操作除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap函数。 13.5 动态内存管理类某些类需要在运行时分配可变大小的内存空间。这种类通常可以使用标准库容器来保存它们的数据。例如，我们的StrBlob类使用一个vector来管理其元素的底层内存。但这一策略并不是对每个类都适用：某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。 13.6 对象移动新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下，对象拷贝后就立即被销毁了。在这些情况下， 移动而非拷贝对象会大幅度提升性能。在旧C++版本中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间，进行不必要的拷贝代价是非常大的。但在新的标准中，我们可以用容器保存不可拷贝的类型，只要他们能被移动即可。 标准库容器、string和shared_ptr类既支持移动页支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 13.6.1 右值引用为了支持移动操作，新的标准引入了一种新的引用类型-右值引用。所谓的右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的，右值引用有一个重要的性质-只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上。123456int i=42;int &amp;r = i; //正确：r引用iint &amp;&amp;rr = i; //错误：不能将一个右值引用绑定到一个左值上int &amp;r2 = i*42; //错误：i*42是一个右值const int &amp;r3 = i*42; //正确：我们可以将一个const的引用绑定到一个左值上int &amp;&amp;rr2 = i*42; //正确：将rr2绑定到乘法结果上 左值持久：右值短暂左值由持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于右值引用只能绑定到临时对象，我们得知： 所引用的对象将要被销毁。 该对象没有其他用户。 这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。 变量是左值变量可以看作只有一个预算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值、右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上。 标准库move函数虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数获得绑定到左值上的右值引用。此函数定义在头文件utility中。 13.6.2 移动构造函数和移动赋值运算符类似string类，如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但他们从给定对象“窃取”资源而不是拷贝资源。移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。除了完成资源移动，移动构造函数还必须确保移动后资源对象处于这样一个状态-销毁它是无害的。特别是，一旦资源完成移动，资源对象必须不再指向被移动的资源-这些资源的所有权已经归属新创建的对象。123456StrVce::StrVec(StrVec &amp;&amp;s)noexcept : elements(s.elements),first_free(s.first_free),cap(s.cap)&#123; s.elements = s.first_free = s.cap = nullptr; &#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章 关联容器]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC11%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素时一些关键字-值（key-value）对：关键字起到索引的作用，值则表示索引相关连的数据。set中每个元素只包含一个关键字；set支持高效的关键字查询操作-检查一个给定的关键字是否在set中。标准容器提供8个关联容器，如下图所示：类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。 11.1 使用关联容器类似顺序容器，关联容器也是模板。为了定义一个map，我们必须指定关键字和值的类型。 11.2 关联容器概述当定义一个map时，必须既指明关键字类型又指明值类型；而定义一个set时，只需指明关键字的类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需的类型就可以。例如，123map&lt;string,size_t&gt; word_count;set&lt;string&gt; exclude = &#123;"the","but","and","or"&#125;;map&lt;string,string&gt; authors = &#123;&#123;"Joyce","James"&#125;,&#123;"Austen","Jane"&#125;,&#123;"Dickens","Charles"&#125;&#125;; multimap或multiset 一个map或set中的关键字必须是唯一的，即，对一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素有相同的关键字。 11.2.2 关键字类型的要求关联容器对其关键字类型有一些限制。对有序容器-map、multimap、set以及multiset，关键字类型必须定义元素的比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。 11.2.3 pair类型pair标准库类型，它定义在头文件utility中，一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将其具有对应的类型。两个类型不要求一样：123pair&lt;string,string&gt; anon;pair&lt;string, size_t&gt; word_count;pair&lt;string, vector&lt;int&gt;&gt; line; pair的默认构造函数对数据成员进行值初始化。与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号可以来访问它们。pair上的操作，如下图所示： 11.3 关联容器操作关联容器还定义了如下所示的类型，这些类型表示容器关键字和值的类型。 对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。 11.3.1 关联容器迭代器当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second保存值：123456auto map_it = word_count.begin();// *map_it指向一个pait&lt;const string, size_t&gt;对象的引用count &lt;&lt;map_it-&gt;first; //打印此元素的关键字cout &lt;&lt; map_it-&gt;second; //打印此元素的值map_it-&gt;first = "new key"; //错误：关键字是const的++map_it-&gt;second; //正确 set的迭代器是const的1234567set&lt;int&gt; iset = &#123;0,1,2,3,4,5,6,7,8,9&#125;;set&lt;int&gt;::iterator set_it = iset.begin();if(set_it!=iset.end())&#123;*set_it = 42; //错误：set中关键字是只读的cout &lt;&lt; *set_it &lt;&lt; endl;&#125; 11.3.2 添加元素关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。关联容器的insert操作如下图所示： 检测insert的返回值 insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已经在容器中，则insert什么事业不做，且返回值中bool部分为false。吐过关键字不存在，元素被插入到容器中，且bool值为true。 11.3.3 删除元素关联容器定义了三个版本的erase，如下图所示。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。者两个版本的erase与对应的顺序容器的操作非常相似；指定的元素被删除，函数返回void。 11.3.4 map的下标操作map和unordered_map容器提供了下标运算符和一个对应at函数。set类型不支持下标运算符。map下标预算符接受一个索引，获取与此关键字 相关联的值。但是，与其他下标运算符不同的是，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。123map&lt;string, size_t&gt; word_count; //empty map//插入一个关键字为Anna的元素，关联值进行值初始化；然后将1赋予它word_count["Anna"] = 1; 11.3.5 访问元素关联容器提供多种查找一个指定元素的方法。如果我们关心的是一个特定的元素是否在容器中，可能find是最佳选择。对于不允许重复关键字的容器，可能使用find还是count没有区别。但是对于允许重复关键字的容器，count还会做更多工作。如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用find。 lower_bound和upper_bound这两个操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配的给定关键字的元素之后的位置。如果元素不在mulitmap中，则lower_bound和upper_bound会返回相等的迭代器-指向一个不影响排序的关键字插入位置。因此，相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围，表示具有该关键字的元素的范围。如果没有元素与给定的关键字匹配，则lower_bound和upper_bound会返回相等的迭代器，都指向给定关键字的插入点，能保持容器中元素顺序的插入位置。 equal_range函数，接受一个关键字，返回一个迭代器pair，如果关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。如果未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。 11.4 无序容器新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素的，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高，此时无序容器也很有用。 除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。 无序容器管理的操作如下图所示： 无序容器对关键字类型的要求默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。我们可以直接定义关键字是内置类型（包括指针类型）、string还是只能指针类型的无序容器。 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 顺序容器]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC9%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一个容器是一些特定类型的对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖与元素的值，而是与容器加入元素时的位置相对应。标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。 9.1 顺序容器概述下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中： 向容器添加或从容器中删除元素的代价。 非顺序访问容器中元素的代价。 确定使用哪种顺序容器以下是一些选择容器的基本原则： 除非有很好的理由选择其他容器，否则应使用vector。 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list 程序要求随机访问元素，应使用vector或deque。 如果程序要求在容器中间插入或删除元素，应使用list或forward_list。 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则 ​首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到vector中。 9.2 容器库概览本节中，介绍的所有容器都适用的操作。一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义在头文件deque中，list定义在头文件list中，以此类推。容器均定义为模板类。必须提供额外信息来生成特定的容器类型。 9.2.1 迭代器迭代器范围 一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者尾元素之后的位置。这两个迭代器通常被称为beign和end，或者是first和last，它们标记了容器中元素的一个范围。beign和end是一个左闭合区间，其标准数学描述为：[beign, end)表示范围自begin开始，于end之前结束。迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。假定begin和end构成一个合法的迭代器范围，则： 如果begin和end相等，则范围为空。 如果begin与end不相等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。 我们可以对begin递增若干次，使得begin==end。 9.2.2 容器类型成员类型别名，通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的value_type。如果需要元素类型的一个引用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程中非常有用。 9.2.4 容器定义和初始化每个容器类型都定义了一个默认构造函数，除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。 将一个容器初始化为另一个容器的拷贝 将一个新容器创建为另一个容器的拷贝方法有两种： 直接拷贝整个容器。 （array除外）拷贝有一个迭代器对指定的元素范围。12345678list&lt;string&gt; authors = &#123;"Milton","Shakespeare","Austen"&#125;;vector&lt;const char*&gt; articles = &#123;"a","an","the"&#125;;list&lt;string&gt; list2(authors); //正确：类型匹配deque&lt;string&gt; authList(authors); //错误：容器类型不匹配vector&lt;string&gt; words(articles); //错误：容器类型不匹配//正确：可以将const char * 元素转换为stringforward_list&lt;string&gt; words(articles.begin(), articles.end()); 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。 与顺序容器大小相关的构造函数 处理与关联容器相同的构造函数外，顺序容器（array）还提供了另一个构造函数，它接受一个容器大小和一个可选元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：1234vector&lt;int&gt; ivec(10,-1); //10个int元素，每个都初始化为-1；list&lt;string&gt; svec(10, "hi!");forward_list&lt;int&gt; ivec(10); //10个元素，每个都初始化为0deque&lt;string&gt; svec(10); //10个元素，每个都是空string 只有顺序容器的构造函数才接受大小参数，关联容器并不支持 9.2.5 赋值和swap下图列出了与赋值相关的运算符可以用于所有容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝：12c1 = c2; //将c1的内容替换为c2中元素的拷贝c1 = &#123;a,b,c&#125;; //赋值后，c1大小为3 使用assign（仅顺序容器） 顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，可以使用assign实现将一个vector中的一段char*值赋予一个list中的string：12345list&lt;string&gt; names;vector&lt;const char*&gt; oldstyle;names = oldstyle; //错误：容器类型不匹配//正确：可以将const char* 转换为stringnames.assign(oldstyle.cbegin(), oldstyle.cend()); assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中的原有的元素：12list&lt;string&gt; slist1(1); //1个元素，为空stringlist.assign(10,"Hiya!"); //10个元素，每个都是"Hiya!" 使用swap swap操作交换两个相同类型的容器的内容，调用swap之后，两个容器中的元素将会交换：123vector&lt;string&gt; svec1(10); //10个元素的vectorvector&lt;string&gt; svec2(24); //24个元素的vectorswap(svec1,svec2); 调用swap后，svec1将包含24个元素，svec2将包含10个元素。除了array外，交换两个容器内容的操作保证会很快–元素本身并未交换，swap只是交换了两个容器内部的数据结构。与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。 9.3 顺序容器的操作9.3.1 向顺序容器添加元素除了array外，所有的标准容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器的大小。下图列出了向顺序容器添加元素的操作。 使用push_back push_back将一个元素追加到一个vector的尾部。除了array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。 关键概念：容器元素时拷贝 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后，对容器中元素的任何改变都不会影响到原始对象，反之依然。 使用push_front除了push_back、list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部：123list&lt;int&gt; ilist;for(size_t ix = 0; ix!=4; ++ix) ilist.push_front(ix); 在容器中特定位置添加元素 insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素位置，而且在容器开始位置插入元素是很有用的功能，所以insert函数将元素插入到迭代器所指定的位置之前。 使用emplace操作新标准引用三个新成员-emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。 9.3.2 访问元素 访问成员函数返回的是引用 在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值。12345678if(!c.empty())&#123; c.front() = 42; //将42赋予c中的第一个元素 auto &amp;v = c.back(); //获得指向最后一个元素的引用 v = 1024; //改变c中的元素 auto v2 = c.back(); //v2不是一个引用，他是c.back()的一个拷贝 v2 = 0; //未改变c中的元素。&#125; 下标操作和安全的随机访问 提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。下标运算符接受一个下标参数，返回容器中该位置元素的引用。给定下标必须在“在范围内”。如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常。 9.3.3 删除元素与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下图所示： 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须要确保它们是存在的。 pop_front和pop_back成员函数 pop_fron和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似地，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。 从容器内部删除一个元素 成员函数erase从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定范围内的所有元素。两种形式的erase都返回指向删除的元素之后的位置的迭代器。即，若j是i之后的元素，那么erase（i）将返回指向j的迭代器。1234567list&lt;int&gt; lst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;auto it = lst.begin();while (it!=lst.end()) if(*it%2) //若元素为奇数 it = lst.erase(it); //删除此元素 else ++it; 删除多个元素接受一对迭代器的erase版本允许我们删除一个范围内的元素：1elem1 = slist.erase(elem1, elem2); //调用后，elem1 == elem2 9.3.5 改变容器的大小如下图所示，我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素都会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。 9.3.6 容器操作可能使迭代器失效向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或者迭代器失效。在向容器添加元素后： 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重现分配，指向插入位置之前的元素迭代器、指针和引用仍会有效，但指向插入位置之后元素的迭代器，指针和引用将会失效。 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。 对于list和forward_list，指向容器的迭代器、指针和引用仍有效。 当我们删除一个元素后： 对于list和forward_list，指向容器其他位置的迭代器、引用和指针仍有效。 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不会受影响；如果是删除首元素，这些页不会受影响。 对于vector和string，指向被删元素之前的迭代器、引用和指针仍有效注意：当我们删除元素时，尾后迭代器总是会失效。 9.4 vector 对象是如何增长的标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。 管理容器的成员函数 vector和string类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动。capacity操作告诉我们容器在不扩展内存空间的情况下可以容纳多个元素。reverse操作允许我们通知容器它应该准备保存多少个元素。reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。只有当需要的内存空间超过当前容量时，reverse调用才会改变vector的容量。如果需求大小大于当前容量，reverse至少分配与需求一样大的内存空间。如果需求大小小于或等于当前容量，reverse什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reverse之后，capacity将会大于或等于传递给reverse的参数。 capacity和size容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。 每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。 9.5 string的额外操作除了顺序容器共同的操作之外，string类型还提供了一些额外的操作。这些操作中的大部分要么提供string类和C风格字符数组之间的相互转换，要么是增加了允许我们用下标代替迭代器的版本。标准库string类型定义了大量函数。幸运的是，这些函数使用了重复的模式。 9.5.1 构造string的其他方法 9.5.2 改变string的其他方法 9.5.3 string的搜索操作 9.5.4 compare函数 9.5.5 数值转换 9.6 容器适配器除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。 栈适配器 队列适配器]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 函数]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC6%E7%AB%A0-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[6.1 函数基础一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对括号之内。 调用函数 函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调函数。此时，主调函数的执行被暂时中断，被调函数开始执行。形参和实参 实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。实参的类型必须与对应的形参类型匹配，这一点与之前的规则是一致的。函数有几个形参，我们就必须提供相同数量的实参。 函数的形参列表 函数的形参列表可以为空，但是不能省略。想要定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。不过为了与C语言兼容，也可以使用关键字void表示函数没有形参：12void f1()&#123;/*...*/&#125; //隐式地定义空形参列表void f2(void) &#123;/*...*/&#125; //显示地定义空形参列表 任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。 6.1.1 局部对象在c++语言中，名字有作用域，对象有声明周期。理解这两个概念非常重要。 名字的作用域是程序文本的一部分，名字在其中可见。 对象的生命周期是程序执行过程中该对象存在的一段时间。形参和函数体内部定义的变量统称为局部变量。 自动对象 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。当块的执行结束之后，块中创建的自动对象的值就变成未定义的了。形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参页就被销毁。 局部静态对象 某些时候，有必要令局部变量的声明周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。 6.1.2 函数声明函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。 6.1.3 分离式编译随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同的文件中。为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持分离式编译，分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。 6.2 参数传递和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋值给形参。当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。 指针形参 指针的行为和其他引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值，拷贝后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。 使用引用避免拷贝 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 如果函数无须改变引用形参的值，最好将其声明为常量引用。 6.2.3 const形参和实参顶层const作用于对象本身：1234const int ci = 42; //不能改变ci，const是顶层的int i = ci； //正确：当拷贝ci时，忽略了它的顶层constint * const p = &amp;i; //const是顶层的，不能给p赋值*p = 0； //正确：通过p改变对象的内容是允许的，现在i变成了0 和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层的const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。想要调用引用版本的reset函数，只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象。类似的，要想调用指针版的reset只能使用int*。另一方面，我们能传递一个字符串字面值作为find_char的第一个实参，这是因为该函数的引用形参是常量引用，而c++允许我们用字面值初始化常量引用。 6.2.4 数组形参数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响。这两个性质分别是：不允许拷贝数组以及使用数组时会将其转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组元素的指针。尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：1234//尽管形式不同，但这三个print函数是等价的，每个函数都有一个const int* 类型的形参void print(const int *);void print(const int []);void print(const int[10]); 因为数组是以指针的形式传递给函数的，所有一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。 使用标记指定数组长度管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。 使用标准库规范管理数组实参的第二种技术是传递指向数组首元素和尾元素的指针。 显示传递一个表示数组大小的形参第三种管理数组实参的方法是专门定义第一个表示数组大小的形参。 数组引用形参 C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上：123456//正确：形参是数组的引用，维度是类型的一部分void print(int (&amp;arr)[10])&#123; for(auto elem: arr) cout &lt;&lt;elem&lt;&lt;endl;&#125; 传递多维数组 C++中实际上没有真正的多维数组，所谓的多维数组其实就是数组的数组。和所有数组一样，将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面的所有维度）的大小都是数组类型的一部分，不能省略。 ###6.2.6 含有可变形参的函数 为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板。C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。 initializer_list形参 如果函数的实参数量未知，但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名头文件中，它提供的操作如表6.1所示： 省略形参 省略形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎一下两种：12void foo(param_listm, ...);void foo(...); 第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参对应的实参无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。 6.3 返回类型和return语句return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return语句有两种形式：12return ;return expression; 6.3.1 无返回值函数没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。一个返回类型的void的函数也能使用return语句的第二种形式，不过此时return语句的expression必须是另一个返回的void函数。强行令void函数返回其他类型的表达式将产生编译错误。 6.3.2 有返回值函数return语句的第二种形式提供了函数的结果，只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句的返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。 不要返回局部对象的引用或指针函数完成之后，它所占用的存储空间也随之被释放掉，因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。 返回类类型的函数和调用运算符 和其他运算符一样，调用运算符也有优先级和结合律，调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能够适应函数调用的结果访问结果的对象的成员。 引用返回左值 函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的得结果赋值。 列表初始化返回值 C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表页用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。 6.3.3 返回函数指针因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名：123typedef int arrT[10]; //arrT是一个类型别名，它表示类型是含有10个整数的数组using arrT = int[10]; //arrT的等价声明arrT* fun(int i); //func 返回一个指向含有10个整数的数组的指针 返回数组指针的函数的形式如下所示：1Type (*function(parameter_list))[dimension] 例如，下面这个func函数的声明没有使用类型别名：1int (*func(int i)) [10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i) 表示调用func函数时需要一个int类型的实参。 (* func(int i)) 意味着我们可以对函数调用的结果执行解引用操作。 (*func(int i))[10] 表示解引用func的调用将得到一个大小是10的数组。 int (* func(int i))[10] 表示数组中的元素类型是int类型。 使用尾置返回类型 在C++11新标准种还有一种可以简化上述func声明的方法，就是使用使用尾置返回类型。任何函数的定义都能使用尾置返回，但这种形式对于返回类型比较复杂的函数比较有效。比如，返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本该出现返回类型的地方放置一个auto：12//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*)[10]; 6.4 函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。这些函数接收的形参类型不一样，但是执行出的操作非常相似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。 main函数不能重载 对于重载函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外，其他的所有要素都相同。 重载和const形参顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另外一个没有顶层const的形参区分开来：12345Record lookup(Phone);Record lookup(const Phone); //重复声明了Record lookup（Phone）Record lookup(Phone *);Recode lookup(Phone* const); //重复声明了Record lookup（Phone *） 另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的常量对象还是非常量对象可以实现函数重载，此时的const是底层的：12345Record lookup(Account &amp;);Record lookup(const Account&amp;); //新函数，作用于常量引用Record lookup(Account *); //新函数，作用于指向Account的指针Record lookup(const Account *); //新函数，作用于指向常量的指针 调用重载的函数 函数匹配是指一个过程，在这个过程，我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。当调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 有多个一个函数可以匹配，但是每一个都不是明显的最佳选择。此时，也将发生错误，称为二义性调用。 6.5 特殊用途语言特性6.5.1 默认实参某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。在定义函数时，我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。 默认实参声明 对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意的是，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 6.5.2 内联函数和constexpr函数内联函数可以避免函数调用的开销将函数指定为内联函数（inline），通常就是将它再每个调用点上“内联地”展开。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。 constexpr函数constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：12constexpr int new_sz() &#123;return 42;&#125;constexpr int foo = new_sz(); //正确：foo是一个常量表达式 constexpr 函数不一定返回常量表达式 把内联函数和constexpr函数放在头文件内 和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟编译器想要展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件。 6.6 函数匹配确定候选函数和可行函数 函数匹配的第一步就是选定本次调用对应的重载函数集，集合中的函数称为候选函数。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。第二步是考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为“可行函数”。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能够转换成形参的类型。 寻找最佳匹配 函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行的函数。基本思想是，实参类型与形参类型越接近，它们匹配得越好。 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型。 向实参添加顶层const或者从实参中删除顶层const。 通过const转换实现的匹配。 通过类型提升实现的匹配。 通过算术类型转换或者指针转换实现的匹配。 通过类类型转换实现的匹配。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 字符串、向量和数组]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[3.1 命名空间的using声明需要注意的事项： 每个名字都需要独立的using声明 头文件不应包含using声明 3.2 标准库类型string标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。包含头文件的代码如下：12#include &lt;string&gt;using std::string; 3.2.1 定义和初始化string对象 初始string对象的方式 string s1 默认初始化，s1是一个空串 string s2(s1) s2是s1的副本 string s3(“value”) s3是字面值“value”的副本，除了字面值最后的空字符外 string s3=“value” 等价于s3(“value”)，s3是字面值”value”的副本 string s4(n, ‘c’) 把s4初始化为连续n个字符c组成的串 直接初始化和拷贝初始化 c++语言有几种不同的初始化方式，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。 3.2.2 string对象上的操作string对象上的操作如下图所示： 读取未知数量的string对象 下面的代码用于读取未知数量的string对象：12345678int main()&#123; string word; while(cin&gt;&gt;word) //反复读取，直到到达文件末尾 cout &lt;&lt; word&lt;&lt;endl; return 0; &#125; 使用getline读取一整行 有时我们希望在最终得到的字符串中保留输入的空白字符，这时应该使用getline函数代替原来的&gt;&gt;运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止，然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。下面是一段示例代码：1234567int main()&#123; string line; while(getline(cin,line)) cout &lt;&lt;line&lt;&lt;endl; return 0;&#125; 3.2.3 处理string对象中的字符cctype头文件定义了一组标准库函数处理字符串，其具体的函数如下图说所示：处理每个字符？使用基于范围的for语句如果想对string对象中的每个字符做点什么操作，目前最好的办法是使用C++11新标准提供的语句：范围for（range for）语句。这种语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，其语法形式是：12for(declaration: expression) statement 其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。下面是遍历string对象的实例：123string str("some string");for(auto c: str) cout&lt;&lt;c&lt;&lt;endl; 3.3 标准库类型vector标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。想要使用vector，必须包含适当的头文件。12#include &lt;vector&gt;using std::vector; vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如，vector。vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所有不存在包含引用的vector。除此之外，其他大多数内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。 3.3.1 定义和初始化vector对象主要类型可以分为如下几类： 默认初始化 列表初始化vector对象 创建指定数量的元素初始化，例如：vector ivec(10, -1); 值初始化，例如，vector ivec(10)，10个元素，每个都初始化为0 3.3.2 向vector对象中添加元素使用push_back()方法可以向vector对象中添加元素。 3.3.3 vector的其他操作 3.4 迭代器介绍迭代器的运算符下表列举了迭代器支持的一些运算。使用==和!=来比较两个合适的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等；否则就说两个迭代器不相等。 标准容器迭代器的运算符 *iter 返回迭代器iter所指元素的引用 iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 –iter 令iter指示容器的上一个元素 iter1 == iter2 判断两个迭代器是否相等，如果两个迭代器指示的同一个元素 iter1!=iter2 或者它们是同一个容器的尾后迭代器，则相等；反之，不相等 begin和end运算符 begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator； 结合解引用和成员访问操作 解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就可以进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it为vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下：1(*it).empty() 为了简化上述表达式，C++语言定义了箭头运算符-&gt;。箭头运算符把解引用和成员访问操作结合在一起，也就是说，iter-&gt;mem和(*it).mem表达的意思相同。 3.4.2 迭代器运算string和vector的迭代器提供了很多额外的运算符，一方面可使得迭代器的每次移动跨过对多个元素，另外也支持迭代器进行关系运算，具体如下图： 3.5 数组与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为，数组的大小固定，因此对某些特殊的应用来说程序的运行时性能比较好，但是相应的损失了一些灵活性。 指针和数组在C++语言中，指针和数组有非常紧密的联系，使用数组的时候编译器一般会把它转换为指针。通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此，像其他元素一样，对数组的元素使用取地址符就能的得到指向该元素的指针：12string nums[] = &#123;"one", "two", "three"&#125;;string *p = &amp;nums[0]; //p指向numsde 第一个元素 数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：1string *p2 = nums; //等价于p2 = &amp;nums[0] 由此，可知在一些情况系数组的操作实际上是指针的操作，当使用数组作为auto变量的初始值时，推断得到的类型是指针而非数组。 指针也是迭代器指向数组元素的指针拥有更多功能。vector和string的迭代器支持的运算，数组的指针全部支持。尽管能够计算得到尾后指针，但这种用法易出错。C++11标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员的功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为他们的参数：123int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *beg = begin(ia); //指向ia首元素的指针int *last = end(ia); //指向ia尾元素的的下一个位置的指针 begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。 解引用和指针运算的交互指针加上一个整数所得的结果还是一个指针。假设结果指针指向一个元素，则允许解引用该结果指针：12int ia[] = &#123;0,2,4,5,8&#125;;int last = *(ia+4); //正确：把last初始化为8，也就是ia[4]的值 最好在必要的地方加上括号，类似的，上例中指针加法的圆括号也必不可少。如果写成下面的形式：1last = *ia + 4; // 正确：last=4等价于ia[0]+4]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 变量和基本类型]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%AC%AC2%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[2.1 基本内置类型 C++提供了一套包括算术类型和空类型在内的基本数据类型。其中，算术类型包括字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。 2.1.1 算术类型算术类型分为两类：整型（包括字符和布尔类型）和浮点型。C++算数类型如下表所示： 含义 类型 最小尺寸 布尔类型 bool 未定义 字符 char 8位 宽字符 wchar_t 16位 Unicode字符 char16_t 16位 Unicode字符 char32_t 32位 短整型 short 16位 整型 int 16位 长整型 long 32位 长整型 long long 64位 单精度浮点数 float 6位有效数字 双精度浮点数 double 10位有效数字 扩展精度浮点数 long double 10位有效数字 除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（singed）和无符号（unsigned）的两种。带符号类型可以表示正数、负数和0，无符号的类型仅能表示大于等于0的值。int、short、long和long long都是带符号的，通过在这些类型前添加unsigned就可以得到无符号类型。与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。尽管字符型有三种，但是字符型的表现形式只有两种：带符号的和无符号的。 如何选择合适的类型 当明确知晓数值不可能为负时，选择无符号类型。 使用int执行整数运算。在实际使用中short常常显得太小，long一般和int有一样的尺寸。如果数值超过了int的表示范围，选用long long。 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用他们。因为类型char在一些机器上是由符号的，而在另一些机器上又是无符号的，所有如果使用char进行运算特别容易出现问题。如果使用的整数为一个不大的整数，那么明确指定它的类型是singed char或unsigned char。 执行浮点数运算选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。 ###2.1.2 类型转换C++类型转换时的处理操作： 将非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为false，否则结果为true。 将布尔值赋给非布尔类型时，初始值为false结果为0，初始值为true结果为1。 将浮点数赋值给整数类型时，进行近似处理，结果值将仅保留浮点数中小数点之前的部分。 将整数值赋值给浮点数时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 当赋值给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 当赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。 2.2 变量变量定义 变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结果结束。1int sum = 0, value, uints_sold= 0; 变量初始化 变量初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象当前值擦除，而以一个新的值来代替。 列表初始化 C++语言定义了初始化的好几种不同的形式，也是初始化问题复杂性的一个体现。例如，定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：1234int units_sold=0;int units_sold = &#123;0&#125;;int units_sold&#123;0&#125;;int units_sold(0); 默认初始化 如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值是由变量类型决定，同时定义变量的位置也会对此有影响。 变量的声明和定义的关系 为了允许把程序拆分为多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的生明。而定义负责创建与名字关联的实体。变量的声明规定了变量的类型和名字，在这一点定义与之相同。但是除此之外，定义还申请存储空间，也可能会为一个变量赋初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而不是显示初始化变量：12extern int i; //声明而非定义iint j; //声明并定义j 任何包含了显示初始化的声明即成为定义。在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 变量能且只能被定义一次，但是可以被多次声明。 变量的作用域 全局作用域，全局作用域内的变量在整个程序的范围内都可使用。如果函数有可能用到全局变量，则不宜再定义一个同名的局部变量。 2.3 复合类型2.3.1 引用引用（reference）为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名：123int ival = 1024;int &amp;refVal = ival; //refVal指向ival（是ival的另一个名字）int &amp;refVal2; //报错:引用必须要被初始化 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而，定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。 为引用赋值，实际上是把值赋给了与引用绑定的对象。因为引用本身不是一个对象，所有不能定义引用的引用。 引用的定义 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：123int i = 1024, i2 = 2048;int &amp;r = i, r2 = i2; //r是一个引用，与i绑定在一起，r2是intint i3 = 1024, &amp;ri = i3;//i3是int，ri是一个引用，与i3绑定在一起 2.3.2 指针指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。定义指针类型的方法是将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*:12int *ip1, *ip2; //ip1和ip2都是指向int型对象的指针double dp, *dp2; //dp2是指向double型对象的指针，dp是double类型对象 获取对象的地址 指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：12int ival = 42;int *p = &amp;ival; //p存放变量ival的地址，或者说p是指向变量ival的指针 指针的类型都要和它所指向的对象严格匹配。 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针，意味着指针没有指向任何对象。 无效指针，也就是上述情况之外的其他值。 利用指针访问对象 如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象：123int ival = 42;int *p = &amp;ival; //p存放着变量ival的地址cout &lt;&lt; *p ; //由符号*得到指针p所指的对象，输出42 对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：12*p = 0; //由符号*得到指针p所指的对象，即可由p为变量ival赋值cout &lt;&lt; *p;//输出0 空指针 空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：123int *p1 = nullptr;int *p2 = 0;int *p3 = NULL; 建议：初始化所有指针 赋值和指针 给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：1234567int i=42;int *pi = 0;int *pi2 = &amp;i; //pi2初始化，存有i的地址int *pi3; //如果pi3定义于块内，则pi3的值是无法确定的pi3 = pi2; //pi3和pi2指向同一个对象ipi2 = 0; //pi2不指向任何对象了 有时太想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指向的对象的值不太容易，最好的办法就是记住赋值永远改变等号左侧的对象。当写出如下语句时：1pi = &amp;ival; //pi的值被改变，现在pi指向了ival 意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如语句：1*pi = 0; //ival的值被改变，指针pi并没有被改变 则*pi（也就是指针pi指向的那个对象）发生改变。void*指针 void*是一种特殊的指针类型，可以用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。我们对该地址中到底是个什么类型的对象不了解。 指向指针的指针 通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推： 123int ival = 1024;int *pi = &amp;ival; //pi指向一个int型的数int **ppi = &amp;pi; //ppi指向一个int型的指针 2.4 const限定符当希望定义一种变量，它的值不能被改变，可以使用关键字const对变量类型加以限定。使其成为const对象，const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字 2.4.1 const的引用可以把引用绑定在conster对象上，就像绑定到其他对象上一样，称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：1234const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1是对常量的引用int &amp;r2 = ci; //错误：试图让一个非常量音引用指向一个常量对象 初始化和对const的引用 引用的类型必须与其所引用的对象的类型一致，但是有个例外：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值。对const的引用可能引用一个并非const的对象。必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是一个非常量，所有允许通过其他途径改变它的值： 12345int i=42;int &amp;r1 = i; //引用r1绑定对象iconst int &amp;r2 = i; //r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0; //r1并非常量，i的值修改为0r2 = 0; //错误：r2是一个常量引用 r2绑定整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。 2.4.2 指针和const指向常量的指针不能用于改变其所指对象的值。要想存放常量对象地址，只能使用指向常量的指针：1234const double pi = 3.14; //pi是个常量double *ptr = &amp;pi; //错误：ptr是一个普通的指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值 指针的类型必须与其所指对象的类型一致，例外情况是：允许令一个指向常量的指针指向一个非常量对象：12double deval = 3.14;cptr = &amp;deval; //正确：但是不能通过cptr改变deval的值 const指针 指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量，即不变的是指针本身的值，而非指向的那个值：1234int errNumb = 0;int * const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; //pip是一个指向常量对象常量指针 要想弄清楚这些声明的含义最有效的方法的是从右向左阅读。 2.5 处理类型2.5.1 类型别名类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用。有两种方法可以用于定义类型别名。传统的方法是使用关键字typedef：12typedef double wages; //wages是double的同义词typedef wages base,*p; //base是double的同义词，p是double*的同义词 新标准规定了一种新的方法，使用别名声明来定义类型的别名：1using SI = Sales_item; //SI是Sales_item的同义词 2.5.2 auto类型说明符在编程时常常需要把表达式的值赋值给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而，有时根本做不到。为了解决这个问题，C++11新标准引用了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量需要有初始值：1auto item = val1 + val2; //item初始化为val1和val2相加的结果 2.5.3 decltype类型指示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++ 11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：1decltype(f()) sum = x; //sum的类型就是函数f的返回类型]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
