<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录思考</title>
  
  <subtitle>ML、DL、NLP</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ilewseu.github.io/"/>
  <updated>2017-11-04T15:34:58.000Z</updated>
  <id>https://ilewseu.github.io/</id>
  
  <author>
    <name>luerwei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>采样方法学习</title>
    <link href="https://ilewseu.github.io/2017/11/04/%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/"/>
    <id>https://ilewseu.github.io/2017/11/04/采样方法/</id>
    <published>2017-11-04T15:08:50.000Z</published>
    <updated>2017-11-04T15:34:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在前两周组内的技术分享中，分享了采样方法。之前在研究生阶段就对采样方法很是疑惑，特别是在看LDA时，用到的Gibbs采样，很多次尝试去学习这一知识点，但都一知半解。所以，借这个机会认真学习一下采样方法相关的知识。本文主要是记录一下自己在学习采样方法时，对不同采样方法原理的理解，主要包括蒙特卡洛方法介绍和5中不同的采样方法。</p></blockquote><h2 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h2><p>首先说一下蒙特卡洛方法，Monte Carlo方法，又称为统计模拟法、随机抽样技术，是一种随机模型方法，以概率和统计理论为基础的一种计算方法。是使用随机数（或伪随机数）来解决很多复杂问题的计算方法。其核心就是通过将所要求解的问题同一定的概率模型相联系，利用计算机进行模拟或抽样，以获得问题的近似解。<br><a id="more"></a><br>简单地理解蒙特卡洛方法，其实就是将要解决的采用一定的方式进行转换，转换之后的问题通过利用计算机实现统计模拟或抽样，从而获得问题是近似解。至于为什么叫Monte Carlo方法，可能是和闻名世界的赌城——摩纳哥的一个小山城有关吧！具体是什么原因，不必去深究。</p><div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171028/25Ij8f5bf5.jpg?imageslim" alt="mark"></div><br>来看一个典型的用Monte Carlo方法解决实际问题的例子。计算圆周率Π的值，如果采用Monte Carlo方法进行计算，可以进行如下的转换：<br><br>- 首先，设置一个边长为1的正方形，其内有一圆，圆的半径为0.5，如下图所示：<br>- 随机的向正方形内打点，打的点在圆内的概率等于圆与正方形的面积之比0.25Π<br>- 随机产生M个点(x,y)，其中，x和y都是区间[0,1]内的符合均匀分布的随机数<br>- 假设落在圆内的点有N个，当M足够大时，根据大数定理，频率等于概率，就有：$$\frac {N} {M} = 0.25Π$$，$$Π=\frac {4N} {M}$$<br>  <img src="http://of6h3n8h0.bkt.clouddn.com/blog/171028/8JHAhdHFAe.jpg?imageslim" alt="mark"><br>实际用代码去模拟一下，得出的圆周率的值为：3.143748，和3.1415926非常接近。<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">samplePI</span><span class="params">(maxCnt = <span class="number">1000000</span>)</span>:</span></div><div class="line">accCnt = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(maxCnt):</div><div class="line">x = np.random.random()</div><div class="line">y = np.random.random()</div><div class="line"><span class="keyword">if</span> np.sqrt(x**<span class="number">2</span> + y**<span class="number">2</span>) &lt; <span class="number">1</span>:</div><div class="line">accCnt += <span class="number">1</span></div><div class="line"><span class="keyword">print</span> <span class="string">"PI="</span>, float(accCnt) / maxCnt *<span class="number">4</span></div></pre></td></tr></table></figure><br><br>通过一个简单的例子，可以直观地理解Monte Carlo方法。采样Monte Carlo方法去解决实际问题一般可以分为如下的步骤：<br><br>- <strong>对复杂的问题进行转换，构造或描述随机过程</strong>。例如，将计算圆周率的问题，转换为在一个正方形内进行打点，将圆周率的值和点在圆内的概率联系起来。<br>- <strong>从已知的概率分布中进行采样,采样出符合特定分布的样本</strong>。例如，从符合[0,1]均匀分布中采样出x和y。<br>- <strong>建立估计量进行计算。</strong><br><br><strong>Monte Carlo方法是一种通用的计算技术，可以解决如下问题</strong>:<br><br>- <strong>随机模拟</strong>：从一个pdf产生”典型”的样本<br>- <strong>计算积分</strong>：在高维空间中的积分<br>- <strong>优化问题</strong><br>- <strong>学习</strong>：MLE:f(x;Θ)<br><br><br>利用Monte Carlo方法去解决实际问题的第2步是从符合特定分布中采样出样本。我们知道，计算机本身无法产生真正的随机数，但可以根据一定的算法产生伪随机数。比如，通过线性同余发生器可以生成伪随机数，我们可以用确定性的算法生成[0,1]之间符合均匀分布的随机数，可以被当成真正的随机数使用。而至于产生符合比较复杂分布的随机数，则是以均匀分布为基础进行采样，以获得符合特定复杂分布的样本，这就是采样方法。不同的采样方法，采样过程不同，但大都基于均匀分布来进行的。下面就分别介绍，几种不同的采样方法。<br><br>## Inverse Transform Sampling<br><br>在介绍不同的采样方法之前，先说一下概率分布，概率分布一般分为连续型和离散型两种，离散型的概率分布一般用概率质量分布函数(pmf)表示，而连续分布用概率密度(pdf)表示,对pmf进行累加或对pdf进行积分的函数，对应于累积分布函数(cdf)。所有pmf的取值之和为1，对pdf在其定义域上进行积分，积分的值为1。<br><br>对于一些简单的分布p(x),我们可以直接进行采样，比如，采样符合p(x)=[0.1,0.3,0.5,0.1]分布的样本 $x=x_1,x_2,x_3,x_4$分布，我们可以直接从Uniform(0,1)采样出一个数，x小于0.1，则采样的值为$x_1$,x等于0.1小于0.4则为$x_2$，以此进行类推。对于比较复杂的分布p(x)，不能直接进行采样。如果要采样的目标分布为p(x),它的累积分布函数F(x)能够求出来，F(x)的反函数也能求出来，那么，Inverse Transform Sampling的采样过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Inverse Transform Sampling</div><div class="line">1. 从Uniform(0,1)中随机采样一个点，用u表示。</div><div class="line">2. 计算$F^-1(u)$的值为x,则x就是服从p(x)的分布的一个样本点。</div></pre></td></tr></table></figure><br><br><strong>简单的证明一下：</strong><br>设F(x)为目标采样分布P(x)的累积分布，$x=F^{-1}(u) u\in[0,1]$为F(x)的反函数。因为F(x)是单调递增的(累积函数的性质)，所以$x=F^{-1}(u)$也是单调递增函数，对于如下不等式:<br>$$F^{-1}(u)\leq F^{-1}(F(x)), if  u \leq F(x)     （1）$$<br>根据反函数的定义有：<br>$$F^{-1}(u) \leq x, if u \leq F(x)   （2）$$<br>根据Uniform(0,1)的定义，其累积分布函数如下：<br><div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171028/bfA64Bb78j.png?imageslim" alt="mark"></div><br>所以，采样出的点的$F^{-1}(u)$累积分布函数如下：<br>$$P(F^{-1}(u) \leq x)=P(u \leq F(x))=H(F(x))=F(x)$$由此可见，采样出的点的累积分布函数为F(x),所以，为符合p(x)分布的样本。<br><br><strong>虽然，利用这种方法可以采样出符合特定分布的样本，但是这种采样方法存在一个缺陷，即，如果要采样的分布p(x)累积分布函数不能够求出来或者累积分布函数没有反函数，这种方法就失效了</strong><br><br>## Acceptance-Rejection Sampling<br><br>对于采样的目标分布p(x),如果其比较复杂，可以采用Acceptance-Rejection Sampling接受-拒绝采样，来进行采样。这种采样方法不直接对p(x)进行采样，而是选择另一个分布q(x)，存在常数M，使得$p(x)\leq Mq(x),\forall x $,称为建议分布(Proposal Density),这个分布容易进行采样，通过对q(x)的采样，来实现对p(x)的采样。其具体的采样过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Acceptance-Rejection Sampling的采样过程：</div><div class="line">1. 从q(x)中随机采样出一个样本点x0</div><div class="line">2. 在从Uniform(0, Mq(x0))中采样出另一个样本点u</div><div class="line">3. 如果u&gt;p(x0),则拒绝x0,并且重复前面的步骤。否则接受x0为符合p(x)分布的样本</div></pre></td></tr></table></figure><br><br><div align="center"><br>  <img src="http://of6h3n8h0.bkt.clouddn.com/blog/171028/111IafA35A.png?imageslim" alt="mark"><br></div><br><strong>这种采样方法可以用计算圆周率的方法来进行理解。把正方形看做一个分布Mq(x),圆形看做要采样的目标分布q(x),通过对Mq(x)进行随机采样，即打点，如点果落在圆内，表明该点符合圆形这个分布，即可以做符合p(x)的样本。</strong>即，如下图所示的圆内的点都是符合圆形这个分布的点。<br><div align="center"><br>  <img src="http://of6h3n8h0.bkt.clouddn.com/blog/171028/8JHAhdHFAe.jpg?imageslim" alt="mark"><br></div><p><strong>Acceptance-Rejection Sampling，通过对q(x)的采样，实现了对p(x)的采样。这种采样方法的接受率正比于$\frac {1} {M}$,等于p(x)下面的面积除以Mq(x)下面的面积。可以看出，只有当M尽可能的小时，采样出的点被接受的概率才会大，从而可以提升采样的效率，因此在使用该方法进行采样是M的选择比较重要。同时,可以看出，如果q(x)和p(x)的形相似时，M就会越小，接受率就会越高。然而，对于高维的目标采样分布，q(x)可能不容易寻找，且M也可能会很大，此时，接受率就会变小，采样效率会变差。</strong></p><h2 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h2><p>Importance Sampling 这种采样方法，其并不是为了获得符合特定分布p(x)的样本，而是为了解决当p(x)不容易进行采样时，计算E[f(x)]，x符合p(x)分布，的问题。其可以进行如下的转换：<br>首先，根据期望的定义，E[f(x)]的计算公式如下：<br>$$<br>E[f(x)] = \int_x f(x)p(x)dx<br>$$<br>因为，p(x)的样本不容易获取，Importance Sampling同样引入一个建议分布q(x)，比较容易获取符合q(x)分布的样本，进行如下转换（以下内容参考：<a href="http://blog.csdn.net/dark_scope/article/details/70992266）：" target="_blank" rel="external">http://blog.csdn.net/dark_scope/article/details/70992266）：</a><br>$$<br>\int_x f(x)p(x)dx = \int_x f(x)\frac {p(x)} {q(x)} q(x) dx<br>= \int_x g(x)q(x)dx    where g(x)=f(x) \frac {p(x)} {q(x)} = f(x)w(x)<br>$$<br>可以看出，通过上面的转化，可以将计算f(x)在p(x)下的期望转化为求g(x)在q(x)分布下的期望。其中，$w(x) = \frac {p(x)} {q(x)}$被称为Importance Weight。<br>但是，有些时候p(x)也是很难计算的，更常见的情况是比较方便的计算$\hat p (x)$和$\hat q(x)$<br>$$p(x) = \frac {\hat p(x) }{Z_p}$$$$p(x) = \frac {\hat p(x)}{Z_p}$$<br>其中，$Z_{p/q}$是一个标准化项，可以看成是一个常数，是的$\hat p(x)$或者$\hat q(x)$等比例变化为一个概率分布，也可以理解为softmax里的分母。其中：<br>$$Z_p=\int_x \hat p(x)dx$$$$Z_q=\int_x \hat q(x)dx$$<br>在这种情况下，Importance Sampling 可以进行如下的转换：<br>$$ \int_x f(x)p(x)dx=\int_x f(x)\frac {p(x)} {q(x)} q(x)dx\\\\ =\int_x f(x) \frac {\hat p(x)/Z_p} {\hat q(x)/Z_q} q(x)dx\\\\=\frac {Z_q}{Z_p} \int_x f(x) \frac {\hat p(x)}{\hat q(x)}\\\\=\frac {Z_q}{Z_p} \int_x \hat g(x)q(x)dx\\\\其中，\hat g(x) = f(x)\frac {\hat g(x)}{\hat q(x)}=f(x)\hat w(x)<br>$$<br>而$\frac {Z_q}{Z_p}$直接计算不太好计算，而它的倒数：<br>$$\frac {Z_p}{Z_q}=\frac {1}{Z_q}\int_x \hat p(x)dx, Z_q=\frac {\hat q(x)} {q(x)} $$<br>所以：<br>$$<br>\frac {Z_p}{Z_q}=\frac {\hat p(x)}{\hat q(x)}q(x)dx = \int_x \hat w(x)q(x)dx<br>$$<br>这样，假设能方便从q(x)进行采样，所以上式又被转换为一个Monte Carlo可解的问题，也就是说：<br>$$<br>\frac {Z_p}{Z_q}=\frac {1}{m} \sum_{i=1}^m \hat w(x_i),  x_i符合q(x)分布。<br>$$<br>最终，求解E[f(x)]的问题可以转换为：<br>$$E[f(x)]=\frac {1}{m} \sum_{i=1}^m \hat w(x_i)f(x_i), 其中，x_i为符合q(x)的样本\\\ \hat w(x_i)=\frac {\hat w(x_i)}{\sum_{i=1}^m \hat w(x_i)}$$<br>所以，我们可以在不用知道q(x)确切值的情况下，就可以近似地计算得到E[f(x)]。其计算过程如下：</p><p><strong>Importance Sampling采样过程</strong>：</p><ol><li>首先为p(x)找到一个建议分布q(x),q(x)比较容易采样。</li><li>然后从q(x)中采样出m个点x</li><li>带入$E[f(x)] = \frac {1}{m} \sum_{i=1}^m \hat w(x_i)f(x_i)$ 计算期望。</li></ol><p>虽然这种方法能够work,但是在高维空间里找到一个这样合适的q(x)非常难。即使有 Adaptive importance sampling 和 Sampling-Importance-Resampling的出现，要找到一个同时满足容易抽样并且和目标分布相似的建议分布，通常是不可能的！</p><h2 id="MCMC-Markov-Chain-Monte-Carlo"><a href="#MCMC-Markov-Chain-Monte-Carlo" class="headerlink" title="MCMC: Markov Chain Monte Carlo"></a>MCMC: Markov Chain Monte Carlo</h2><p>Importance Sampling和Acceptance-Rejection Sampling虽然能够实现对一些分布的采样，但是只有当选取的建议分布q(x)和要进行采样的目标分布p(x)很近似时才表现好，所以选取合适的q(x)是非常关键。当在高维空间进行采样，标准的采样方法会失败，对于Acceptance-Rejection Sampling,当目标分布的维数增高时，拒绝率会趋近于100%，采样的效率会很低。对于Importance Sampling，大多数的样本的权重值会趋近于0。对于高维复杂问题，可以用马尔科夫链（Markov Chain)产生一系列相关样本，实现对目标分布的采样。</p><p><strong>MCMC是一种用一定范围内的均匀分布的随机数对高维空间概率进行采样的通用技术，其基本思想是设计一个马尔科夫链，使得其稳定概率分布为要采样的目标分布$\pi(x)$</strong></p><div align="center"><br>    <img src="http://of6h3n8h0.bkt.clouddn.com/blog/171104/I648eamalb.png?imageslim" alt="mark"><br></div><p><strong>首先来看一下马尔科夫链的定义及其平稳分布：</strong></p><ul><li><strong>马尔科夫性质</strong>：某一时刻状态转移的概率只依赖于它前一个状态</li><li><strong>定义</strong>：假设存在状态序列$… X_{t-2},X_{t-1},X_t,X_{t+1}…$,时刻t+1的状态的条件概率只依赖于t时刻的状态$x_t$,即：<br>$$P(X_{t+1}|…X_{t-2},X_{t-1},X_t)=P(X_{t+1}|X_t)$$</li><li><strong>马尔科夫链：</strong>满足马尔科夫性质的随机过程<br>以天气变化来解释一下上面的定义，<br>假设每天的天气是一个状态的话，状态转移可以看成是天气的变化，比如从晴天变成阴天、从阴天变成雨天等。马尔科夫性质讲的是，今天的天气情况只依赖于昨天的天气，和前天以及之前的天气状况没有任何关系。马尔科夫链可以看成每天的天气按照这个规律进行变化的一个过程。一个马尔科夫链可以由下面的公式定义：<br><div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171104/CiGC5gDKG9.png?imageslim" alt="mark"><br></div><br>一个马尔科夫链一般由三部分构成：</li><li><strong>状态空间</strong>：可以理解为天气状况的所有情况 {阴天，晴天，雨天，…}</li><li><strong>初始状态</strong>：可以理解为第一天的天气情况</li><li><strong>状态转移矩阵</strong>：可以理解为所有由一种天气状况变为另一种天气状况的概率<br>马尔科夫链具有一个非常重要的性质：<strong>马尔科夫链的平稳分布</strong>。来看一个例子，假设一个国家的人口地域分布分为：农村、城镇和城市3种状态。每年人口流动情况如下图：<br><div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171104/51FefCKmHe.png?imageslim" alt="mark"><br></div><br>上图表示每种状态转移到另一种状态的概率。如果定义矩阵P，P的某一位置P(i,j)的值为P(j|i)，表示从状态i转换为状态j的概率，则根据上图可以得到马尔科夫链的状态转移矩阵为：<br><div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171104/0abfm4cm48.png?imageslim" alt="mark"><br></div><br>假设初始状态的人口地域分布为$\pi_0=[\pi_0(1),\pi_0(2),\pi_0(3)]$，每年人口按照状态转移矩阵P进行转移，n年后人口的地域分布为$\pi_n=\pi_{n-1}P=…=\pi P^n$。假设存在如下两种初始的人口分布：</li><li>$\pi_0=[0.5,0.4,0.1]$</li><li>$\pi_0=[0.3,0.4,0.3]$<br>按照状态转移矩阵进行转移一定年数后的人口分布情况分布如下图所示：<div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171104/D6l5b55I3g.png?imageslim" alt="mark"><br></div><br><div align="center"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171104/3kkJia7CKA.png?imageslim" alt="mark"><br></div></li></ul><p>可以看出，尽管采用了不同的初始化状态，但最终的概率分布都趋近于一个稳定的概率分布[0.167,0.388,0.444]。可以看到，<strong>马尔科夫链模型的状态转移矩阵收敛到稳定概率分布和初始状态概率分布无关。也就是说，如果得到了稳定概率分布对应的马尔科夫链模型的状态转移矩阵，我们可以从任意的概率分布样本开始，带入马尔科夫链模型的状态转移矩阵，经过一系列的状态转移，最终样本的分布会趋近于稳定的概率分布</strong>。</p><p>用数学的语言来定义一下马尔科夫链的收敛性质：<br><strong>如果一个非周期的马尔科夫链，其状态转移矩阵为P，并且它的任何两个状态之间是联通的，那么$\lim_{n \rightarrow +\infty} P_{ij}^n$  与i无关，则有：</strong></p><ol><li>$\lim_{n \rightarrow +\infty} P^n = \begin{bmatrix}<br>{\pi(1)}&amp;{\pi(2)}&amp;{\cdots}&amp;{\pi(n)}\\\\<br>{\pi(1)}&amp;{\pi(2)}&amp;{\cdots}&amp;{\pi(n)}\\\\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\\\<br>{\pi(1)}&amp;{\pi(2)}&amp;{\cdots}&amp;{\pi(n)}\\\\<br>\end{bmatrix}$</li><li>$\pi(j)=\sum_{i=0}^\infty P_{ij}$，$p_{ij}$表示状态i转移到状态j的概率</li><li>$\pi$是方程$\pi P = \pi$的唯一非负解，其中，$$\pi=[\pi(1),\pi(2),….,\pi(j),…] \sum_{i=0}^\infty \pi(i)=1$$</li></ol><p>上面的性质中有如下的说明：</p><ul><li>非周期的马尔科夫链：主要是指马尔科夫链的状态转化不是循环的，如果是循环的则永远不会收敛。我们一般遇到的马尔科夫链一般都是非周期性的。用数学方式可以表述为：对于任意某一状态i,d为集合${n | n\geq 1,P_{ij}^n &gt; 0}$的最大公约数为1，如果d=1，则该状态为非周期的。</li><li>任何两个状态是联通的：指从任意一个状态可以通过有限步到达其他的任意一个状态，不会出现条件概率为0导致不可达的情况。</li><li>马尔科夫链的状态可以是有限的，也可以是无限的。因此，可以用于连续概率分布和离散概率分布。</li><li>$\pi$通常称为马尔科夫链的平稳分布。</li></ul><h3 id="基于马尔科夫链的采样方法"><a href="#基于马尔科夫链的采样方法" class="headerlink" title="基于马尔科夫链的采样方法"></a>基于马尔科夫链的采样方法</h3><p>从马尔科夫链的收敛性质可以看出，如果我们能够得到某个平稳分布对应的马尔科夫链状态转移矩阵，就很容易采样出这个平稳分布的样本。<br>假设任意初始化的概率分布为$\pi_0(x)$，经过第一轮转移后的概率分布是$\pi_0(x)$，经过i轮后的概率分布为$\pi_i(x)$。假设经过n轮后马尔科夫链收敛到平稳分布$\pi(x)$,即：<br>$$\pi_n(x)=\pi_{n+1}(x)=…=\pi(x)$$<br>那么经过n轮之后的，沿着状态转移矩阵进行转移得到的样本都是符合$\pi(x)$分布的样本。<strong>也就是说，如果从一个具体的初始状态$x_0$出发，沿着马尔科夫链按照状态转移矩阵进行跳转，假设n次跳转后收敛，那么得到一个转移状态序列$X_0,X-1,…,X_n,X_{n+1},….$，则$X_n,X_{n+1},…$都是符合平稳分布$\pi(x)$的样本。</strong><br><strong>基于马尔科夫链的采样过程如下：</strong></p><ol><li>输入： 状态转移矩阵P，设定状态转移次数$n_1$，需要采样的样本个数$n_2$</li><li>从任意概率分布采样得到一个初始状态值$x_0$</li><li>for t=0 to $n_1+n_2 - 1$：<strong>从条件概率分布$P(x|x_t)$中采样出样本为$x_{t+1}$</strong></li><li>输出：样本$(x_{n_1},x_{n_1+1},…,x_{n_1+n_2})$即为符合平稳分布$\pi(x)$的样本。</li></ol><p><strong>解释一下上面的从条件概率分布$P(x|x_t)$中采样出样本为$x_{t+1}$。为什么要从$P(x|x_t)$中进行采样？</strong><br><strong>因为，当前的状态为$x_t$，从当前状态$x_t$进行转移，可转移到的状态为状态空间集合，所以要以当前状态为条件向其他状态进行转移，所以要从$P(x|x_t)$中进行采样。例如，人口分布的例子，假设当前的状态是农村，那么从农村转移到农村、城镇和城市的概率分别为0.5、0.4和0.1，即$P(x|x_t)=[0.5,0.4,0.1]$，转移时要按照这个分布进行转移，即采样时要按照这个分布进行采样，使用均匀分布可以很容易实现。而状态转移为连续的情况，则$P(x|x_t)$则是一个具体的连续分布，通过对$P(x|x_t)$的采样，实现转移。</strong></p><p>可以看出，我们要采样的目标分布为$\pi(x)$,如果我们能够构建一个状态转移矩阵P，使得其马氏链上的平稳分布是$\pi(x)$，那么初始化一个状态，按照状态转移矩阵P进行转移，经过n次后收敛，第n+1次后的样本都是符合$\pi(x)$分布的。所以，<strong>MCMC采样方法的关键是构建状态转移矩阵P。如何构建这个状态转移矩阵P呢？首先看一下马尔科夫链的细致平稳条件</strong>：<br><strong>如果一个非周期的马尔科夫链状态转移矩阵为P和概率分布$\pi(x)$，对于所有的i，j满足：$$<br>\pi(i)P(i,j)=\pi(j)P(j,i)$$</strong>其中，P(i,j)表示状态i转移到状态j的概率,则称$\pi(x)$是状态转移矩阵P的平稳分布。<br><strong>证明：</strong>$$<br>\sum_{i=1}^\infty \pi(i)P(i,j)=\sum_{i=1}^\infty \pi(j)P(j,i)=\pi(j)\sum_{i=1}^\infty P(j,i) = \pi(j)<br>$$<br>写成矩阵的形式，即：$$\pi P=\pi$$由于$\pi$是$\pi P=\pi$的解，所以$\pi$是一个平稳分布。上式被称为细致平稳条件(detailed balance condition)。 其实这个定理是显而易见的，因为细致平稳条件的物理含义就是对于任何两个状态i,j 从i转移出去到j而丢失的概率质量，恰好会被从j转移回i的概率质量补充回来，所以状态i上的概率质量$\pi(i)$是稳定的，从而$\pi(x)$是马尔科夫链的平稳分布。<br>从细致平稳条件可以看出，只要找到可以使概率分布$\pi(x)$满足细致平稳分布的矩阵P即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在前两周组内的技术分享中，分享了采样方法。之前在研究生阶段就对采样方法很是疑惑，特别是在看LDA时，用到的Gibbs采样，很多次尝试去学习这一知识点，但都一知半解。所以，借这个机会认真学习一下采样方法相关的知识。本文主要是记录一下自己在学习采样方法时，对不同采样方法原理的理解，主要包括蒙特卡洛方法介绍和5中不同的采样方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;蒙特卡洛方法&quot;&gt;&lt;a href=&quot;#蒙特卡洛方法&quot; class=&quot;headerlink&quot; title=&quot;蒙特卡洛方法&quot;&gt;&lt;/a&gt;蒙特卡洛方法&lt;/h2&gt;&lt;p&gt;首先说一下蒙特卡洛方法，Monte Carlo方法，又称为统计模拟法、随机抽样技术，是一种随机模型方法，以概率和统计理论为基础的一种计算方法。是使用随机数（或伪随机数）来解决很多复杂问题的计算方法。其核心就是通过将所要求解的问题同一定的概率模型相联系，利用计算机进行模拟或抽样，以获得问题的近似解。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://ilewseu.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Sampling Methods" scheme="https://ilewseu.github.io/tags/Sampling-Methods/"/>
    
  </entry>
  
  <entry>
    <title>编写可读代码的艺术-读书笔记</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://ilewseu.github.io/2017/10/10/编写可读代码的艺术-读书笔记/</id>
    <published>2017-10-10T15:24:38.000Z</published>
    <updated>2017-10-10T15:41:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章-把信息装到名字里"><a href="#第二章-把信息装到名字里" class="headerlink" title="第二章 把信息装到名字里"></a>第二章 把信息装到名字里</h3><p>​     主题是：把信息塞入名字中。即，读者仅通过读到名字就可以获得大量的信息。主要有以下几点：</p><ul><li><strong>使用专业的单词</strong>–例如，不用Get，而用Fetch或者Download可能会更好，这由上下文决定。</li><li><strong>避免空泛的名字，像tmp和retval</strong>，除非使用它们有特殊的理由。</li><li><strong>使用具体的名字来更细致地描述事物</strong>——ServerCanStart()<a id="more"></a>这个名字就比CanListenOnPort更不清楚。</li><li><strong>给变量名带上重要的细节</strong>——例如，在值为毫秒的变量后加上_ms，或者在还需要转义的、未处理的变量前加上raw_。</li><li><strong>为作用域大的名字采用更长的名字</strong>——不要用让人费解的一个或两个字母的名字来命名在几屏之间都可见的变量。对于只存在于几行之间的变量用短一点的名字更好。</li><li><strong>有目的地使用大小写、下划线等</strong>——例如，可以在类成员和局部变量后面加上“_”来区分它们。<h3 id="第三章-不会误解的名字"><a href="#第三章-不会误解的名字" class="headerlink" title="第三章 不会误解的名字"></a>第三章 不会误解的名字</h3>​      不要误解的名字是最好的名字——阅读你代码的人应该理解你的本意，并且不会有其他的理解。  </li><li>在决定使用一个名字以前，要想象一下你的名字被误解成什么。最好的名字是不会误解的。</li><li>当要定义一个值的上限或下限时，max_和min_是很好的前缀。对弈包含的范围，first和last是好的选择。对于包含/排除范围，begin和end是好的选择。</li><li>当为布尔值命名时，使用is和has这样的词来明确表示它是一个布尔值，避免使用反义的词。</li><li>要小心用户对特定词的期望。例如，用户会期望get()或者size()是轻量的方法。<h3 id="第四章-审美"><a href="#第四章-审美" class="headerlink" title="第四章 审美"></a>第四章 审美</h3>​       通过把代码用一致的、有意义的方式“格式化”，可以把代码变得更容易读，并且可以读得更快。下面是讨论过的一些具体技巧:</li><li>如果多个代码块做相似的事情，尝试让他们有同样的剪影。</li><li>把代码按“列”对齐可以让代码更容易浏览。</li><li>如果在一段代码中提到A、B和C，那么不要在另一段中说B、C和A。选择一个有意义的顺序，并始终用这样的顺序。</li><li>用空行来把大块分成逻辑上的“段落”。<h3 id="第五章-该写出什么样的注释"><a href="#第五章-该写出什么样的注释" class="headerlink" title="第五章 该写出什么样的注释"></a>第五章 该写出什么样的注释</h3>   注释的目的是帮助读者了解作者在写代码时已经知道的那些事情。本章主要介绍如何发现所有的不那么明显的信息块并把它们写下来。<br><strong>什么地方不需要注释:</strong></li><li>能从代码本身中迅速地推断的事实。</li><li>用来粉饰烂代码的“拐杖式注释”——应该把代码改好。<br><strong>应该记录下来的想法包括:</strong></li><li>对于为什么代码写成这样而不是那样的内在理由（“指导性批注”）。</li><li>代码中的缺陷，使用像TODO:或者XXX:这样的标记。（TODO:还没有处理的事情；FIXME：已知的无法运行的代码；HACK：对一个问题不得不采用的比较粗暴的解决方案；XXX：危险！这里有重要的问题）</li><li>常量背后的故事，为什么是这个值。<br><strong>站在读者的立场上思考:</strong></li><li>预料到代码中哪些部分会让读者产生疑问，并且给它们加上注释。</li><li>为普通读者意料之外的行为加上注释。</li><li>在文件/类的级别上使用“全局观”注释来解释所有的部分是如何一起工作的。</li><li>用注释来总结代码块，使读者不致迷失在细节中。<h3 id="第六章-如何写出言简意赅的注释"><a href="#第六章-如何写出言简意赅的注释" class="headerlink" title="第六章 如何写出言简意赅的注释"></a>第六章 如何写出言简意赅的注释</h3></li><li>当像“it”和“this”这样的代词可能指代多个事物时，避免使用它们。</li><li>尽量精确地描述函数的行为。</li><li>在注释中用精心挑选的输入/输出例子进行说明。</li><li>声明代码的高层次意图，而非明显的细节。</li><li>用嵌入的注释来解释难以理解的函数参数。</li><li>用含义丰富的词来使注释简洁。<h3 id="第七章-把控制流变得易读"><a href="#第七章-把控制流变得易读" class="headerlink" title="第七章  把控制流变得易读"></a>第七章  把控制流变得易读</h3>有几种方法可以让代码的控制流更易读</li><li>在写一个比较时（while （bytes_expected &gt; bytes_received）），把改变的值写在左边，并且把更稳定的值写在右边更好一些（while （bytes_received &lt; bytes_expected））。</li><li>可以重新排列if/else语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时这种准则会冲突，但是当不冲突时，这是要遵守的经验法则。</li><li>某些编程结构，像三目运算符(:?)、do/while循环，以及goto经常会导致代码的可读性变差。最好不要使用它们，因为总是有更整洁的代替方式。</li><li>嵌套的代码块需要更加集中精力去理解。每层新的嵌套都需要读者把更多的上下文“压入栈”。应该把它们改写成更加“线性”的代码来避免深嵌套。</li><li>通常来讲提早返回可以减少嵌套并让代码整洁。“保护语句”（在函数顶部处理简单的情况时）尤其有用。<h3 id="第八章-拆分超长的表达式"><a href="#第八章-拆分超长的表达式" class="headerlink" title="第八章  拆分超长的表达式"></a>第八章  拆分超长的表达式</h3><blockquote><p><strong>关键思想：</strong>把超长的表达式拆分为更容易理解的小块</p></blockquote></li><li>引入“解释变量”来代表较长的子表达式。这种方式有三个好处：<ul><li>它把巨大的表达式拆成小段；</li><li>它通过用简单的名字描述子表达式来让代码文档化；</li><li>它帮助读者识别代码中的主要概念。</li></ul></li><li>用德摩根定理来操作逻辑表达式——这个技术可以把布尔表达式用更整洁的方式重写；</li><li>任何复杂逻辑的地方都可以进行拆分。<h3 id="第九章-变量与可读性"><a href="#第九章-变量与可读性" class="headerlink" title="第九章 变量与可读性"></a>第九章 变量与可读性</h3><strong>减少变量</strong><ul><li>删除没有价值的临时变量</li><li>减少中间结果</li><li>减少控制变量<br><strong>缩小变量的作用域</strong><blockquote><p><strong>关键思想:</strong>让你的变量对尽量少的代码行可见。</p></blockquote></li></ul></li></ul><p><strong>只写一次的变量更好</strong><br><strong>总结</strong><br>   本章是关于程序中的变量是如何快速累积而变得难以跟踪的。你可以通过减少变量的数量和让它们尽量“轻量级”来让代码更有可读性。具体有：</p><ul><li><strong>减少变量。</strong></li><li><strong>减少每个变量的作用域，越小越好。把变量移到一个有最少代码可以看到的地方。</strong></li><li><strong>只写一次的变量更好。</strong>那些只设置一次的变量（或者const、final、常量）使得代码更容易理解。<h3 id="第十章-抽取不相关的子问题"><a href="#第十章-抽取不相关的子问题" class="headerlink" title="第十章 抽取不相关的子问题"></a>第十章 抽取不相关的子问题</h3>​    本章一个简单的总结就是“把一般代码和项目专有的代码分开“。其结果是，大部分的代码都是一般代码。通过建立一大组库和辅助函数来解决一般问题，剩下的只是让你的程序与众不同的核心部分。<br>​    这个技巧有帮助的原因是它使程序员关注小而定义良好的问题，这些问题已经同项目的其他部分脱离。其结果是，对于这些子问题的解决方案倾向于更加完整和正确。你也可以再以后重用它们。<h3 id="第十一章-一次只做一件事"><a href="#第十一章-一次只做一件事" class="headerlink" title="第十一章 一次只做一件事"></a>第十一章 一次只做一件事</h3><blockquote><p><strong>关键思想：</strong>应该把代码组织得一次只做一件事情</p></blockquote></li></ul><p>​    如果你有很难读的代码，尝试把它所做的所有任务列出来。其中一些任务可以很容易地变成单独的函数。其他的可以简单地变成为一个函数中的逻辑”段落”。具体如何拆分这些任务没有它们已经分开这个事实那样重要。难的是要准确地面描述你的程序所做的所有这些小事情。  </p><h3 id="第十二章-把想法变成代码"><a href="#第十二章-把想法变成代码" class="headerlink" title="第十二章 把想法变成代码"></a>第十二章 把想法变成代码</h3><p>​    本章讨论了一个简单的技巧，用自然语言描述程序然后用这个描述来帮助你写出更自然的代码。这个技巧出人意料地简单，但很强大。看到你在描述中所用的词和短语还可以帮助你发现哪些子问题可以拆分出来。但是这个“用自然语言说事情”的过程不仅可以用于写代码。另一个看待这个问题的角度是：如果你不能把问题说明白或者用词语来做设计，估计是缺少什么东西或者什么东西缺少定义。把一个我那天变成语言可以让它变得更具体。</p><h3 id="第十三章-少写代码"><a href="#第十三章-少写代码" class="headerlink" title="第十三章 少写代码"></a>第十三章 少写代码</h3><blockquote><p><strong>关键思想:</strong>最好的代码就是没有代码。</p></blockquote><ul><li>质疑和拆分你的需求</li><li>保持小的代码库</li></ul><p>​        随着项目的增长，项目加进来的越来越多的源文件。项目很大，没有一个人自己全部理解它。增加新功能会变得很痛苦，而且使用这些代码还很费力还令人不快。最好的解决办法就是”让你的代码库越小，越轻量级越好“，可以尝试如下方法：</p><pre><code>1. 创建越多越好的”工具“代码来减少重复代码；2. 减少无用代码或没用的功能；3. 让你的项目保持分开的子项目状态；4. 总的来说，要小心代码的”重量“。让它保持又轻又灵。</code></pre><ul><li>熟悉你周边的库</li></ul><p><strong>总结</strong></p><p>​    本章是关于写越少代码越好的。每行新的代码都需要测试、写文档和维护。另外，代码库中的代码越多，它就越”重“，而且在其上开发就越难。可以通过以下方法来避免重新编写新代码：</p><ul><li>从项目中消除不必要的功能，不要过度设计；</li><li>重新考虑需求，解决版本最简单的问题，只要能完成工作就行；</li><li>经常性地通读标准库的整个API，保持对他们的熟悉程度。</li></ul><h3 id="第十四章-测试与可读性"><a href="#第十四章-测试与可读性" class="headerlink" title="第十四章 测试与可读性"></a>第十四章 测试与可读性</h3><p>在测试代码中，可读性仍然很重要。如果测试的可读性很好，其结果是他们也会变得很容易写，因此大家会写更多的测试。并且，如果你把事实代码设计得容易测试，代码设计会变得更好。以下是如何改进测试的具体要点：</p><ul><li>每个测试的最高一次应该越简明越好。最好每个测试的输入/输出可以用一行代码描述；</li><li>如果测试失败了，它所发出的错误消息应该能让你容易跟踪并修正这个bug；</li><li>使用最简单的并且能够完整运用代码的测试输入；</li><li>给测试函数取一个有完整描述性的名字，以使每个测试所测到的东西很明确。不要用Test1()，而要像Test_<functionname>__<situation>这样的名字。</situation></functionname></li></ul><p>最重要的是，要使它易于改动和增加新的测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第二章-把信息装到名字里&quot;&gt;&lt;a href=&quot;#第二章-把信息装到名字里&quot; class=&quot;headerlink&quot; title=&quot;第二章 把信息装到名字里&quot;&gt;&lt;/a&gt;第二章 把信息装到名字里&lt;/h3&gt;&lt;p&gt;​     主题是：把信息塞入名字中。即，读者仅通过读到名字就可以获得大量的信息。主要有以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用专业的单词&lt;/strong&gt;–例如，不用Get，而用Fetch或者Download可能会更好，这由上下文决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免空泛的名字，像tmp和retval&lt;/strong&gt;，除非使用它们有特殊的理由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用具体的名字来更细致地描述事物&lt;/strong&gt;——ServerCanStart()
    
    </summary>
    
      <category term="程序猿的自我修养" scheme="https://ilewseu.github.io/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="程序猿的自我修养" scheme="https://ilewseu.github.io/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>第7章 类</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC7%E7%AB%A0-%E7%B1%BB/"/>
    <id>https://ilewseu.github.io/2017/10/10/第7章-类/</id>
    <published>2017-10-10T15:23:14.000Z</published>
    <updated>2017-10-10T15:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><p><strong>构造函数</strong></p><p>每个类都分别定义了它的对象初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。<br><a id="more"></a><br>构造函数的名字和类名相同，和其他函数不一样的是，构造函数没有返回类型；除此之外类似于其他的函数，构造函数也有一个参数列表和一个函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。</p><p>不同于其他成员函数，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。</p><p><strong>默认构造函数</strong></p><p>类通过一个特殊的构造函数来控制默认初始化的过程，这个函数叫做<strong>默认构造函数</strong>。默认构造函数无须任何实参。如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为<strong>合成的默认构造函数</strong>。对于大多数来说，这个合成的默认构造函数按照如下规则初始化类的数据成员：</p><ul><li>如果存在类内的初始化值，用它类初始化成员。</li><li>否则，默认初始化该成员。</li></ul><p><strong>某些类不能依赖于合成的默认构造函数</strong></p><p>合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义它自己的默认构造函数。其原因如下：</p><ul><li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。</li><li>对于某些类来说，合成的默认构造函数可能执行错误的操作。</li><li>有时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类，我们必须要自定义默认构造函数，否则该类将没有可用的默认构造函数。</li></ul><p><strong>构造函数初始值列表</strong><br>如果编译器不支持内置初始值，那么默认的构造函数就应该使用构造函数初始值列表来初始化类的每个成员。例如，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s):bookNo(s)&#123;&#125;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):bookNo(s),units_sold(n), revenue(p*n) &#123;&#125;</div></pre></td></tr></table></figure></p><p>我们把括号里的部分称为<strong>构造函数初始值列表</strong>，它负责为新创建的对象的一个或几个数据成员赋值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值。不同成员的初始化通过逗号分隔开来。</p><p>通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予一个正确的值。不过如果编译器不支持类内初始值，则所有的构造函数都应该显式地初始化每个内置类型的成员。</p><blockquote><p>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p></blockquote><h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><p>在C++语言中，我们使用<strong>访问说明符</strong>加强类的封装性：</p><ul><li>定义在<strong>public</strong>说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</li><li>定义在<strong>private</strong>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，<strong>private</strong>部分封装了类的实现细节。</li></ul><blockquote><p>使用class和struct定义类的唯一区别就是默认的访问权限。</p></blockquote><h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元。如果想把一个函数作为它的友元，只需增加一条以friend关键字开始的函数声明语句即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line"><span class="comment">//为Sales_data的非成员函数所做的友元声明</span></div><div class="line">  <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</div><div class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, Sales_data&amp; )</span></span>;</div><div class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp; ,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</div><div class="line">  <span class="keyword">public</span>：</div><div class="line">  <span class="comment">//...</span></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。<strong>一般来说，最好在类定义开始或结束前的位置集中声明友元</strong>。</p><p><strong>封装的益处</strong></p><p>封装有两个重要的优点：</p><ul><li>确保用户代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li></ul><h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><p><strong>可变数据成员</strong></p><p>有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入<strong>mutable</strong>关键字做到这一点。一个可变数据成员永远不会是const，即使它是const对象成员。因此，一个const成员函数可以改变一个可变成员的值。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line"> <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr; <span class="comment">//即使在一个const对象内也能被修改</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> Screen::some_member() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  ++access_ctr; <span class="comment">//保存一个计数值，用于记录成员函数被调用的次数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。</p><p><strong>类类型</strong><br>每个类定义了唯一的类型，对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。对于一个类来说，它的成员和其他任何类的成员都不是一回事。<br>就像可以把函数的声明和定义分离开来一样，我们也能仅声明类而暂时不定义它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span> <span class="comment">//Screen类的声明</span></div></pre></td></tr></table></figure></p><p>这种声明有时被称作前向声明，它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型，也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。<br>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明以不完全类型作为参数或者返回类型的函数。对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。</p><h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><p><strong>类之间的友元关系</strong></p><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。必须要注意的一点是，友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。</p><p><strong>令成员函数作为友元</strong></p><p>除了令整个windo_mgr作为友元之外，Screen还可以只为clear挺访问权限。当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line"><span class="comment">//Window_mgr::clear必须在Screen类之前被声明</span></div><div class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> Window_mrg::clear(ScreenIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要想令某个成员函数作为友元，我们必须仔细组织程序的结构，以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：</p><ul><li>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员函数之前必须先声明Screen。</li><li>接下来定义Screen，包括对于clear的友元声明。</li><li>最后定义clear，此时它才可以使用Screen的成员。</li></ul><h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><p>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。不论哪种情况，跟在运算符之后的名字都必须是对应类的成员。</p><p><strong>名字查找与类的作用域</strong><br>在编写的程序中，名字查找（寻找与所用名字最匹配的声明的过程）的过程比较直接了当：</p><ul><li>首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。</li><li>如果没有找到，继续查找外层作用域。</li><li>如果最终没有找到匹配的声明，则程序报错。</li></ul><p>对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的例子中体现的不太明显。类的定义分为两步处理：</p><ul><li>首选，编译成员的声明。</li><li>直到类全部可见后才编译函数体。</li></ul><p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而，在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能再之后重新定义改名字。</p><p><strong>成员定义中普通块作用域的名字查找</strong><br>成员函数中使用的名字按照如下方式解析：</p><ul><li>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。</li><li>如果在成员函数内没有找到，则在类内进行查找，这时类的所有成员都可以被考虑。</li><li>如果类内也没有找到该名字的声明，在成员函数定义之前的作用域内继续查找。</li></ul><h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><blockquote><p>如果成员是const、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。</p></blockquote><p><strong>成员函数的初始化顺序</strong></p><p>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p><p>一般来说，初始化的顺序没有什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。</p><p><strong>默认实参和构造函数</strong></p><blockquote><p>如果一个构造函数为所有的参数都提供了默认实参，则它实际上也定义了默认构造函数。</p></blockquote><p><strong>委托构造函数</strong></p><p>C++11新标准扩展了构造函数的初始值的功能，使得我们可以定义所谓的<strong>委托构造函数</strong>。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="comment">//非委托构造函数使用对应的实参初始化成员</span></div><div class="line">  Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price):</div><div class="line">  bookNo(s),units_sold(cnt),revenue(cnt* price)&#123;&#125;</div><div class="line">  </div><div class="line">  <span class="comment">//其余构造函数全都委托给另一个构造函数</span></div><div class="line">  Sales_data():Sales_data(<span class="string">""</span>, <span class="number">0</span> , <span class="number">0</span>) &#123;&#125;</div><div class="line">  Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> a):Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</div><div class="line">  Sales_data(<span class="built_in">std</span>::istream &amp;is):Sales_data()&#123; reda(is, *<span class="keyword">this</span>);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作给另一个函数。</p><p><strong>默认构造函数的作用</strong></p><p>当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：</p><ul><li>当我们在块作用域内不是要任何初始值定义一个非静态变量或者数组时。</li><li>当一个类本身含有类类型的成员且使用合成的默认构造函数时。</li><li>当类类型的成员没有在构造函数初始值列表中显示地初始化时。</li></ul><p>值初始化在以下情况发生：</p><ul><li>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。</li><li>当我们不使用初始值定义一个局部静态变量时。</li><li>当我们通过书写形如T()的表达式显式地请求值初始化时，其中T是类型名。</li></ul><p>类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。</p><p><strong>隐式的类类型转换</strong></p><p>抑制构造函数定义的隐式转换，在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止。explicit构造函数只能用于直接初始化。发生隐式转换的一种情况是当我们执行拷贝形式的初始化时，此时我们只能使用直接初始化而不能使用explicit构造函数。</p><p><strong>聚合类</strong><br>聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：</p><ul><li>所有的成员都是public的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有virtual函数。</li></ul><h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><p><strong>声明静态成员</strong></p><p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123; amount += amount * interestrate;&#125;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestrate;&#125;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> owner;</div><div class="line">  <span class="keyword">double</span> amount;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">double</span> interestrate;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有的Account对象共享。</p><p>静态成员不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明为const的，而且我们也不能再static函数体内使用this指针。</p><p><strong>定义静态成员</strong></p><p>和其他成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只能出现在类内部的声明语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Account::rate(<span class="keyword">double</span> newRate)</div><div class="line">&#123;</div><div class="line">  interestRate = newRate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。类似全局变量，静态数据成员定义在任何函数之外。因此，一旦它被定义，就将一直存在于程序的整个生命周期中。</p><blockquote><p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p></blockquote><p><strong>静态成员的类内初始化</strong></p><p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态成员指定数组成员的维度：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> interestRate;&#125;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period = <span class="number">30</span>; <span class="comment">//period是常量表达式</span></div><div class="line">  <span class="keyword">double</span> daily_tbl[period];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static 不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须要有一条定义语句。</p><blockquote><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;7-1-定义抽象数据类型&quot;&gt;&lt;a href=&quot;#7-1-定义抽象数据类型&quot; class=&quot;headerlink&quot; title=&quot;7.1 定义抽象数据类型&quot;&gt;&lt;/a&gt;7.1 定义抽象数据类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个类都分别定义了它的对象初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vi编辑器使用</title>
    <link href="https://ilewseu.github.io/2017/10/10/Vi%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://ilewseu.github.io/2017/10/10/Vi编辑器使用/</id>
    <published>2017-10-10T15:17:50.000Z</published>
    <updated>2017-10-10T15:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、vi编辑器概述"><a href="#1、vi编辑器概述" class="headerlink" title="1、vi编辑器概述"></a>1、vi编辑器概述</h2><h3 id="1-1-启动vi编辑器"><a href="#1-1-启动vi编辑器" class="headerlink" title="1.1 启动vi编辑器"></a>1.1 启动vi编辑器</h3><p>启动vi编辑器的方式如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>vi filename，vim filename</td><td>从filename文件的第1行开始编辑，即光标默认停留在文件的第1行第一个字符处。</td></tr><tr><td>vi/vim + n filename</td><td>从filename文件的第n行开始编辑，即光标默认停留在文件的第n行的第一个字符处</td></tr><tr><td>vi/vim + filename</td><td>从filename文件的最后1行开始编辑，即光标默认停留在文件的最后一行第一个字符处。</td></tr><tr><td>vi/vim +/.pattern filename</td><td>从filename文件的第1行包含字符串“pattern”的行开始编辑</td></tr><tr><td>vi/vim -r filename</td><td>在系统崩溃后恢复filename</td></tr><tr><td>vi/vim -R filename</td><td>以只读的方式编辑filename</td></tr></tbody></table><a id="more"></a><p>当用vim打开并编辑一个文件时，该文件会被自动锁定。如果此时另一用户也希望打开该文件进行编辑将会出现一些提醒：</p><ul><li>以只读方式打开文件：按字母键o，用户以只读方式打开文件，不会影响其他用户对该文件的同时操作。</li><li>直接编辑：按字母键e，可以直接编辑该文件，但与其他同时操作的文件的用户在存盘时可能会冲突。</li><li>恢复：按字母键r。如果出现在该界面是由上一次编辑此文件时崩溃引起的，选择该选项可以恢复修改内容。</li><li>退出：按字母键q，直接退出vi编辑器。</li></ul><h3 id="1-2退出vi"><a href="#1-2退出vi" class="headerlink" title="1.2退出vi"></a>1.2退出vi</h3><p>退出vi可按下Esc键，然后输入q即可退出vi，返回Shell提示符。</p><h3 id="1-3-命令模式"><a href="#1-3-命令模式" class="headerlink" title="1.3 命令模式"></a>1.3 命令模式</h3><p>用户可以输入命令，通过命令实现移动光标、删除或修改部分文本以及如复制、粘贴、退出等操作。命令一经输入就立即执行，不需要按回车键。不管在什么模式下，只要按一下Esc键，即可将vi切换到命令模式下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前字符前插入文本</td></tr><tr><td>I</td><td>在当前行的行首插入文本</td></tr><tr><td>a</td><td>在当前字符之后追加文本</td></tr><tr><td>A</td><td>在当前行的行尾追加文本</td></tr><tr><td>o</td><td>在当前行的下面添加一新行</td></tr><tr><td>O</td><td>在当前行的上面添加一新行</td></tr></tbody></table><h3 id="1-4-末行模式"><a href="#1-4-末行模式" class="headerlink" title="1.4 末行模式"></a>1.4 末行模式</h3><p>在命令模式下按下冒号键即可切换到末行模式。此时光标停留在最后一行上，并等待用户输入所需执行的末行命令。当用户输入命令后，按回车键，命令即可被执行。例如，输入命令set number并按回车键后，使得光标跳到指定的行。</p><h2 id="1-2-vi中常用命令"><a href="#1-2-vi中常用命令" class="headerlink" title="1.2 vi中常用命令"></a>1.2 vi中常用命令</h2><h3 id="1-2-1-插入命令：i和I"><a href="#1-2-1-插入命令：i和I" class="headerlink" title="1.2.1 插入命令：i和I"></a>1.2.1 插入命令：i和I</h3><h3 id="1-2-2-附加文本命令：a和A"><a href="#1-2-2-附加文本命令：a和A" class="headerlink" title="1.2.2 附加文本命令：a和A"></a>1.2.2 附加文本命令：a和A</h3><h3 id="1-2-3-字符与块删除命令"><a href="#1-2-3-字符与块删除命令" class="headerlink" title="1.2.3 字符与块删除命令"></a>1.2.3 字符与块删除命令</h3><p>在命令行模式下，删除命令分两种，一种是字符删除命令，一种是块删除命令<br>删除字符使用x/X命令，x命令可以删除当前字符，X命令可以删除当前光标左侧字符。如果在使用命令前指定了重复的次数，可连续删除多个字符。例如，命令3w表示删除从当前光标位置开始向后的3个字符，命令3W表示删除当前光标之前的3个字符。<br>命令d/D可以把指定的文本块从工作缓冲区中删除。命令D表示删除从当前光标开始到本行未尾一段字符。命令d还需配合其他命令组合来确定删除文本块的大小。具体的使用如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>X</td><td>删除当前光标左侧字符</td></tr><tr><td>dl</td><td>与命令x相同</td></tr><tr><td>d0</td><td>从行的开始处删除</td></tr><tr><td>d$ 或 D</td><td>删除到行的末尾</td></tr><tr><td>dw</td><td>删除到单词的末尾</td></tr><tr><td>d)</td><td>删除到句子末尾</td></tr><tr><td>dd</td><td>删除一行</td></tr><tr><td>dL</td><td>删除到当前屏幕的最后一行（包括最后一行）</td></tr><tr><td>3dd</td><td>删除当前行开始的3</td></tr><tr><td>dH</td><td>从当前屏幕的第1行开始删除</td></tr></tbody></table><h3 id="1-2-4-行合并命令：J"><a href="#1-2-4-行合并命令：J" class="headerlink" title="1.2.4 行合并命令：J"></a>1.2.4 行合并命令：J</h3><p>在命令行模式 下，合并命令可将当前行的末尾与下一行连接起来，并在两行之间插入一个空格，合并后光标定位到该空格处。如果当前行以句号结束，则会在两行之间插入两个空格。</p><h3 id="1-2-5-文本替换命名"><a href="#1-2-5-文本替换命名" class="headerlink" title="1.2.5 文本替换命名"></a>1.2.5 文本替换命名</h3><p>在命令行模式下，替换命令s/S可以删除指定的文本，并使vi进行插入模式。命令s只替换当前字符，即删除当前光标所在位置的字符并切换到插入模式。命令S与命令cc类似，可以删除当前行并切换到插入模式。编辑完文本后，按esc键可以切换到命令模式，完成替换操作。<br>在命令s前加入数字可以指定要替换字符的数目。例如，3s表示删除从当前光标所在字符开始的3个字符，并且切换到插入模式。如果指定的数目超出了当前行的行尾，则删除到行尾结束。</p><h3 id="1-2-6-句点命令"><a href="#1-2-6-句点命令" class="headerlink" title="1.2.6 句点命令"></a>1.2.6 句点命令</h3><p>在命令行模式下，句点命令将重复执行最近一次的修改命令。例如，如果刚刚用命令dd删除了当前一行，那么命令.将会继续删除接下来的一行。</p><h3 id="1-2-7-撤销修改命令：u-U"><a href="#1-2-7-撤销修改命令：u-U" class="headerlink" title="1.2.7 撤销修改命令：u/U"></a>1.2.7 撤销修改命令：u/U</h3><p>vi包括一个通用缓冲区和26个命名缓冲区，vi会将最近的修改保存在通用缓冲区中，撤销命令实际上是从通用缓冲区取出文本并进行恢复操作。在编辑修改文本之后，在命令行模式下直接使用撤销命令可以恢复到文本修改之前的状态。<strong>撤销修改命令包括u和U命令</strong><br>命令u可以撤销上一次的编辑操作。执行一次u命令只能撤销上一次对文本的操作。如果删除一行后又插入了某些字符，则执行一次u命令只能删除插入的字符。如果希望恢复删除的行，则需要再执行一次u命令。<br>命令U可以撤销当前的所有修改，将文本恢复到启动修改之前的状态。</p><h3 id="1-2-8-复制命令：y-Y"><a href="#1-2-8-复制命令：y-Y" class="headerlink" title="1.2.8 复制命令：y/Y"></a>1.2.8 复制命令：y/Y</h3><p>赋值命令实际是把指定的文本内容复制到通用缓冲区。复制命令包括y和Y命令，需要在命令模式下使用。<br>命令yy可以复制一行，默认是当前行。如果需要复制多行，可以在命令yy前指定行数，例如3yy可以复制当前开始的3行文本。<br>命令Y与yy类似。</p><h3 id="1-2-9-粘贴命令：p-P"><a href="#1-2-9-粘贴命令：p-P" class="headerlink" title="1.2.9 粘贴命令：p/P"></a>1.2.9 粘贴命令：p/P</h3><p>命令p把通用缓冲区的内容插入到当前字符之后。<br>命令P把通用缓冲区的内容插入到当前字符之前。</p><h3 id="1-2-10-重复执行-ctrl-r"><a href="#1-2-10-重复执行-ctrl-r" class="headerlink" title="1.2.10 重复执行 ctrl+r"></a>1.2.10 重复执行 ctrl+r</h3><p>如果撤销某个命令后又想重新执行该命令，可以在命令模式下使用组合键Ctrl+R，也可以在末行模式下输入命令：redo并按回车键，vi会重新执行已被撤销的命令。重复命令也可以连续执行多次。</p><h2 id="1-3-vi中字符与文件操作"><a href="#1-3-vi中字符与文件操作" class="headerlink" title="1.3 vi中字符与文件操作"></a>1.3 vi中字符与文件操作</h2><p>vi可以在整个缓冲区查找与正则表达式匹配的字符串。在命令模式下，键入斜杠(/)后跟待查找的字符串，按回车键，vi即可开始搜索。状态行将同步显示插入的斜杠和搜索字符串。如果搜索成功，光标会停留在首次匹配该字符串的第1个字符处。按n键可以<strong>向后</strong>重复上一次搜索，按N键可以<strong>向前</strong>重复上次的搜索。</p><h3 id="1-3-1-查找指定字符命令"><a href="#1-3-1-查找指定字符命令" class="headerlink" title="1.3.1 查找指定字符命令"></a>1.3.1 查找指定字符命令</h3><p>在命令行模式下，命令f可以在当前行当前光标出开始查找指定的字符，并将光标移动到该字符出现的位置。如果没有找到，则不移动光标。F命令与f类似，只是在本行开始的位置到光标所在位置之间查找。</p><p>命令t在查找字符时，会将光标定位在指定字符出现位置前一个字符位置，而命令T在查找字符时会将光标定位在指定字符出现的后一字符位置。</p><h3 id="1-3-2-替换指定字符串"><a href="#1-3-2-替换指定字符串" class="headerlink" title="1.3.2 替换指定字符串"></a>1.3.2 替换指定字符串</h3><p>在末行模式下的替换命令s具有查找和修改功能。替换命令首先查找某个字符串，然后修改该字符串。末行模式下的替换命令s语法格式如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:[g] [address] s/ search/replacement [/option]</div></pre></td></tr></table></figure></p><p>其中，g表示在所有的行进行查找和替换，否则只对第一次查找的结果进行替换。address表示查找的范围，如果不指定address，默认只搜索当前行。search表示搜索的字符串，replace表示替换字符串，/为分隔符。</p><blockquote><p>分隔符可以使用除字母、数字、空白符和反斜杠之外的任意其他字符，但应保持search前后的分隔符相同。</p></blockquote><table><thead><tr><th>address示例</th><th>说明</th></tr></thead><tbody><tr><td>3</td><td>第3行</td></tr><tr><td>22,100</td><td>从22行到100行之间，包括22行和100行</td></tr><tr><td>5, .</td><td>从第5行开始至当前行</td></tr><tr><td>5,$</td><td>从第5行值末尾</td></tr><tr><td>%</td><td>整个缓冲区</td></tr><tr><td>g/pattern</td><td>包含字符串pattern的所有行</td></tr><tr><td>/pattern/</td><td>搜索到首次包含字符串pattern 的行</td></tr><tr><td>.,. +20</td><td>从当前行开始向后的连续20行</td></tr><tr><td>.,. -10</td><td>从当前行开始向前的连续10行</td></tr></tbody></table><table><thead><tr><th style="text-align:left">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">:s/string1/string2</td><td>将当前行中第1次搜索到的字符串string1替换为string2</td></tr><tr><td style="text-align:left">:1,.s/string1/string2/g</td><td>将当前行之前的所有行中的字符串string1替换为string2，其中g表示在每一行中都允许进行多次替换</td></tr><tr><td style="text-align:left">:1,$s/string1/string2/g</td><td>将所有的行中出现字符串string1替换为string2</td></tr><tr><td style="text-align:left">:%s/string1/string2/g</td><td>将所有的行中出现字符串string1替换为string2</td></tr><tr><td style="text-align:left">:.,.+10s/string1/string2/g</td><td>将从当前行开始连续10行内出现的字符串string1替换为string2</td></tr><tr><td style="text-align:left">:/string/s/string1/string2/g</td><td>将首次串string的行中字符串string1替换为string2</td></tr><tr><td style="text-align:left">:g /string/s/string1/string2</td><td>在所有行中将包含string字符串的行中的第一次出现string1的字符串替换为string2</td></tr><tr><td style="text-align:left">:g /string/s/string1/string2/g</td><td>在所有行中将包含string字符串的行中的string1的字符串替换为string2</td></tr><tr><td style="text-align:left">5,.s/string1/string2</td><td>将第5行到当前行之间所有行中出现的string1替换为string2</td></tr></tbody></table><h3 id="1-3-3-更改大小写的命令"><a href="#1-3-3-更改大小写的命令" class="headerlink" title="1.3.3 更改大小写的命令"></a>1.3.3 更改大小写的命令</h3><p>在命令模式下，代字符（~）可以用来更改字母的大小写，可以将小写字母改为大写，也可以将大写字母改为小写。</p><h3 id="1-3-4-定位到指定行命令"><a href="#1-3-4-定位到指定行命令" class="headerlink" title="1.3.4 定位到指定行命令"></a>1.3.4 定位到指定行命令</h3><p>在命令模式下，输入命令“行号+G”可以将当前光标定位到缓冲区中指定的行， 如果没有指定行号，默认将光标定位到缓冲区的最后一行。命令G不需要缓冲区显式地给出行号，即即使不显示行号，也可以定位到指定的行。例如，在命令行模式下，输入3G可以将光标定位到缓冲区第3行。</p><h3 id="1-3-5-显示状态信息命令"><a href="#1-3-5-显示状态信息命令" class="headerlink" title="1.3.5 显示状态信息命令"></a>1.3.5 显示状态信息命令</h3><p>显示文件状态信息通常有 两种方式：在命令模式下，按ctrl+G组合键和在末行模式下使用命令f</p><h3 id="1-3-6-保存和退出命令"><a href="#1-3-6-保存和退出命令" class="headerlink" title="1.3.6 保存和退出命令"></a>1.3.6 保存和退出命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:w</td><td>保存缓冲区，但不退出。保存后磁盘中的文件被修改，不能恢复</td></tr><tr><td>:w filename</td><td>将缓冲区的内容保存到指定的filename中</td></tr><tr><td>ZZ</td><td>保存并退出，在命令下使用</td></tr><tr><td>:q</td><td>退出，但如果缓冲区已经被修改将提示错误信息，不能退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>q!</td><td>直接退出，系统不进行警告</td></tr></tbody></table><h2 id="1-4-窗口操作"><a href="#1-4-窗口操作" class="headerlink" title="1.4 窗口操作"></a>1.4 窗口操作</h2><h3 id="1-4-1-窗口操作的快捷方式"><a href="#1-4-1-窗口操作的快捷方式" class="headerlink" title="1.4.1 窗口操作的快捷方式"></a>1.4.1 窗口操作的快捷方式</h3><ul><li>组合键ctrl+W+S：用于打开编辑同一个文件的另一个窗口，即用于实现窗口的水平切分。</li><li>组合键ctrl+W+N：可以用于打开一个新的窗口编辑一个新的文件。</li><li>组合键Ctrl+W+W：可以实现多个窗口之间的切换。</li></ul><h3 id="1-4-2-窗口垂直拆分：vsplit"><a href="#1-4-2-窗口垂直拆分：vsplit" class="headerlink" title="1.4.2 窗口垂直拆分：vsplit"></a>1.4.2 窗口垂直拆分：vsplit</h3><h3 id="1-4-3-窗口水平拆分：split"><a href="#1-4-3-窗口水平拆分：split" class="headerlink" title="1.4.3 窗口水平拆分：split"></a>1.4.3 窗口水平拆分：split</h3><h3 id="1-4-4-屏幕滚动"><a href="#1-4-4-屏幕滚动" class="headerlink" title="1.4.4 屏幕滚动"></a>1.4.4 屏幕滚动</h3><p>当一个文件的行数超出了屏幕所能显示的最大行数时，需要上下滚动文本才能观察到全部内容。滚动的方向是相对文本而言的，不是相对屏幕。向下滚动意味着向文件的结尾处移动。具体滚动命令如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ctrl+Y</td><td>向上滚动一行</td></tr><tr><td>ctrl+E</td><td>向下滚动一行</td></tr><tr><td>ctrl+U</td><td>向上滚动半屏</td></tr><tr><td>ctrl+D</td><td>向下滚动半屏</td></tr><tr><td>ctrl+F</td><td>向下滚动整屏</td></tr><tr><td>ctrl+B</td><td>向上滚动整屏</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、vi编辑器概述&quot;&gt;&lt;a href=&quot;#1、vi编辑器概述&quot; class=&quot;headerlink&quot; title=&quot;1、vi编辑器概述&quot;&gt;&lt;/a&gt;1、vi编辑器概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-启动vi编辑器&quot;&gt;&lt;a href=&quot;#1-1-启动vi编辑器&quot; class=&quot;headerlink&quot; title=&quot;1.1 启动vi编辑器&quot;&gt;&lt;/a&gt;1.1 启动vi编辑器&lt;/h3&gt;&lt;p&gt;启动vi编辑器的方式如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vi filename，vim filename&lt;/td&gt;
&lt;td&gt;从filename文件的第1行开始编辑，即光标默认停留在文件的第1行第一个字符处。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vi/vim + n filename&lt;/td&gt;
&lt;td&gt;从filename文件的第n行开始编辑，即光标默认停留在文件的第n行的第一个字符处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vi/vim + filename&lt;/td&gt;
&lt;td&gt;从filename文件的最后1行开始编辑，即光标默认停留在文件的最后一行第一个字符处。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vi/vim +/.pattern filename&lt;/td&gt;
&lt;td&gt;从filename文件的第1行包含字符串“pattern”的行开始编辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vi/vim -r filename&lt;/td&gt;
&lt;td&gt;在系统崩溃后恢复filename&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vi/vim -R filename&lt;/td&gt;
&lt;td&gt;以只读的方式编辑filename&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://ilewseu.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://ilewseu.github.io/tags/Linux/"/>
    
      <category term="工具使用" scheme="https://ilewseu.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>第13章 拷贝控制</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC13%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>https://ilewseu.github.io/2017/10/10/第13章-拷贝控制/</id>
    <published>2017-10-10T15:17:00.000Z</published>
    <updated>2017-10-10T15:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章主要学习类如何控制该类型对象拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数控制这些操作，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。</p></blockquote><p>当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五中特殊的成员函数来控制这些操作。包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。拷贝和移动构造函数定义了当用同类型的同一个对象初始化对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。<br><a id="more"></a></p><h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">Foo(); <span class="comment">//默认构造函数</span></div><div class="line">Foo(<span class="keyword">const</span> Foo&amp;); <span class="comment">//拷贝构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>拷贝构造函数的第一个参数必须是一个引用类型。拷贝构造函数通常不应该是explicit的。</p><p><strong>合成拷贝构造函数</strong></p><p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</p><p>对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。</p><p>每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。</p><p><strong>拷贝初始化</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>,<span class="string">'.'</span>)</span></span>; <span class="comment">//直接初始化</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(dots)</span></span>; <span class="comment">//直接初始化</span></div><div class="line"></div><div class="line"><span class="built_in">string</span> s2 = dots; <span class="comment">//拷贝初始化</span></div><div class="line"><span class="built_in">string</span> null_book = <span class="string">"9-9999-9999"</span>;<span class="comment">//拷贝初始化</span></div></pre></td></tr></table></figure></p><p>当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p><p><strong>拷贝初始化发生的情况</strong></p><ul><li>使用=号定义变量时。</li><li>将一个对象作为实参传递给一个非引用类型的实参。</li><li>用花括号列表初始化一个数组中的元素或一个聚合类的成员。</li></ul><p><strong>参数和返回值</strong></p><p>在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</p><p>拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功-为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。</p><h3 id="13-1-2-拷贝赋值运算符"><a href="#13-1-2-拷贝赋值运算符" class="headerlink" title="13.1.2 拷贝赋值运算符"></a>13.1.2 拷贝赋值运算符</h3><p>与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。</p><h3 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h3><p>在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照他们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后按照成员初始化顺序的逆序销毁成员。</p><p><strong>什么时候会调用析构函数</strong><br>无论何时一个对象被销毁，就会自动调用其析构函数：</p><ul><li>变量在离开其作用域时被销毁。</li><li>当一个对象被销毁时，其成员被销毁。</li><li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li><li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。</li><li>对于临时对象，当创建它的完整表达式结束时被销毁。</li></ul><p>由于析构函数自动运行，我们的程序可以按需分配需要的资源，而无须担心何时释放这些资源。</p><h3 id="13-1-5-使用-default"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用=default"></a>13.1.5 使用=default</h3><p>我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  <span class="comment">//拷贝控制成员：使用default</span></div><div class="line">  Sales_data() = <span class="keyword">default</span>;</div><div class="line">  Sales_data(<span class="keyword">const</span> Sales_data &amp;) = <span class="keyword">default</span>;</div><div class="line">  Sales_data&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Sales_data &amp;);</div><div class="line">  ~Sales_data() = <span class="keyword">default</span>;</div><div class="line">  <span class="comment">//其他成员的定义，</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。</p><h3 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h3><blockquote><p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式还是显式地。</p></blockquote><p>虽然，大多数的类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p><p><strong>定义删除的函数</strong></p><p>在新的标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为<strong>删除的函数</strong>来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的列表后面加上=delete来指出我们希望它地定义为删除的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span>&#123;</span></div><div class="line">  NoCopy() = <span class="keyword">default</span>; <span class="comment">//使用合成的默认构造函数</span></div><div class="line">  NoCopy(<span class="keyword">const</span> NoCopy&amp;)=<span class="keyword">delete</span>; <span class="comment">//阻止拷贝</span></div><div class="line">  NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;<span class="comment">//阻止赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>=delete通知编译器，我们不需要定义这些成员。</p><p>与default不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此=default直到编译器生成代码时才需要。另一方面，编译器需要直到一个函数是删除的，以便禁止试图使用它的操作。</p><p>与=defalut的另外一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。</p><p><strong>析构函数不能是删除的成员</strong></p><p><strong>合成的拷贝控制成员可能是删除的</strong><br>如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似地，如果一个类未定义构造函数，编译器会为其合成一个默认的构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数：</p><ul><li>如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。</li><li>如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。</li><li>如果类的某个成员的拷贝赋值运算符时删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。</li><li>如果类的某个成员的析构函数是删除的或不可访问的，或是有一个引用成员，它没有类内初始化器、或是类有一个const成员，它没有类初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。</li></ul><p>本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p><h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><p>通常管理类外资源的类必须定义拷贝控制成员。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。<br>为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝的操作，使类的行为看起来像一个值或像一个指针。</p><p>类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象的时候，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。</p><p>行为像指针的类则共享状态。当我们拷贝一个这类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p><h2 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h2><p>除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap函数。</p><h2 id="13-5-动态内存管理类"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类</h2><p>某些类需要在运行时分配可变大小的内存空间。这种类通常可以使用标准库容器来保存它们的数据。例如，我们的StrBlob类使用一个vector来管理其元素的底层内存。但这一策略并不是对每个类都适用：某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。</p><h2 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下，对象拷贝后就立即被销毁了。在这些情况下， 移动而非拷贝对象会大幅度提升性能。<br>在旧C++版本中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间，进行不必要的拷贝代价是非常大的。但在新的标准中，我们可以用容器保存不可拷贝的类型，只要他们能被移动即可。</p><blockquote><p>标准库容器、string和shared_ptr类既支持移动页支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p></blockquote><h3 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h3><p>为了支持移动操作，新的标准引入了一种新的引用类型-右值引用。所谓的右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的，右值引用有一个重要的性质-只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。<br>一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。<br>类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">//正确：r引用i</span></div><div class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">//错误：不能将一个右值引用绑定到一个左值上</span></div><div class="line"><span class="keyword">int</span> &amp;r2 = i*<span class="number">42</span>; <span class="comment">//错误：i*42是一个右值</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i*<span class="number">42</span>; <span class="comment">//正确：我们可以将一个const的引用绑定到一个左值上</span></div><div class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i*<span class="number">42</span>; <span class="comment">//正确：将rr2绑定到乘法结果上</span></div></pre></td></tr></table></figure></p><p><strong>左值持久：右值短暂</strong><br>左值由持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。<br>由于右值引用只能绑定到临时对象，我们得知：</p><ul><li>所引用的对象将要被销毁。</li><li>该对象没有其他用户。</li></ul><p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p><blockquote><p>右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。</p></blockquote><p><strong>变量是左值</strong><br>变量可以看作只有一个预算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值、右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上。</p><p><strong>标准库move函数</strong><br>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数获得绑定到左值上的右值引用。此函数定义在头文件utility中。</p><h3 id="13-6-2-移动构造函数和移动赋值运算符"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符</h3><p>类似string类，如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但他们从给定对象“窃取”资源而不是拷贝资源。<br>移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。除了完成资源移动，移动构造函数还必须确保移动后资源对象处于这样一个状态-销毁它是无害的。特别是，一旦资源完成移动，资源对象必须不再指向被移动的资源-这些资源的所有权已经归属新创建的对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StrVce::StrVec(StrVec &amp;&amp;s)<span class="keyword">noexcept</span> :</div><div class="line">elements(s.elements),first_free(s.first_free),cap(s.cap)&#123;</div><div class="line">      </div><div class="line">      s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章主要学习类如何控制该类型对象拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数控制这些操作，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五中特殊的成员函数来控制这些操作。包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。拷贝和移动构造函数定义了当用同类型的同一个对象初始化对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第11章 关联容器</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC11%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://ilewseu.github.io/2017/10/10/第11章-关联容器/</id>
    <published>2017-10-10T15:16:44.000Z</published>
    <updated>2017-10-10T15:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素时一些关键字-值（key-value）对：关键字起到索引的作用，值则表示索引相关连的数据。set中每个元素只包含一个关键字；set支持高效的关键字查询操作-检查一个给定的关键字是否在set中。<br><a id="more"></a><br>标准容器提供8个关联容器，如下图所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/kI1hKJB5ba.jpg?imageslim" alt="mark"><br>类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。</p></blockquote><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><p>类似顺序容器，关联容器也是模板。为了定义一个map，我们必须指定关键字和值的类型。</p><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><p>当定义一个map时，必须既指明关键字类型又指明值类型；而定义一个set时，只需指明关键字的类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需的类型就可以。例如，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt; word_count;</div><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"the"</span>,<span class="string">"but"</span>,<span class="string">"and"</span>,<span class="string">"or"</span>&#125;;</div><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; authors = &#123;&#123;<span class="string">"Joyce"</span>,<span class="string">"James"</span>&#125;,&#123;<span class="string">"Austen"</span>,<span class="string">"Jane"</span>&#125;,&#123;<span class="string">"Dickens"</span>,<span class="string">"Charles"</span>&#125;&#125;;</div></pre></td></tr></table></figure></p><p><strong>multimap或multiset</strong></p><p>一个map或set中的关键字必须是唯一的，即，对一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素有相同的关键字。</p><h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><p>关联容器对其关键字类型有一些限制。对有序容器-map、multimap、set以及multiset，关键字类型必须定义元素的比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p><h3 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a>11.2.3 pair类型</h3><p>pair标准库类型，它定义在头文件utility中，一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将其具有对应的类型。两个类型不要求一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; anon;</div><div class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</div><div class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; line;</div></pre></td></tr></table></figure></p><p>pair的默认构造函数对数据成员进行值初始化。与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号可以来访问它们。pair上的操作，如下图所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/CAbifckkCL.jpg?imageslim" alt="mark"></p><h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><p>关联容器还定义了如下所示的类型，这些类型表示容器关键字和值的类型。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/kG4gbiF2c9.jpg?imageslim" alt="mark"></p><p>对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。</p><h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second保存值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> map_it = word_count.begin();</div><div class="line"><span class="comment">// *map_it指向一个pait&lt;const string, size_t&gt;对象的引用</span></div><div class="line">count &lt;&lt;map_it-&gt;first;  <span class="comment">//打印此元素的关键字</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;second; <span class="comment">//打印此元素的值</span></div><div class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">//错误：关键字是const的</span></div><div class="line">++map_it-&gt;second; <span class="comment">//正确</span></div></pre></td></tr></table></figure></p><p><strong>set的迭代器是const的</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = iset.begin();</div><div class="line"><span class="keyword">if</span>(set_it!=iset.end())</div><div class="line">&#123;</div><div class="line">*set_it = <span class="number">42</span>; <span class="comment">//错误：set中关键字是只读的</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><p>关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。关联容器的insert操作如下图所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/ddfhKeLF6f.jpg?imageslim" alt="mark"></p><p><strong>检测insert的返回值</strong></p><p>insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已经在容器中，则insert什么事业不做，且返回值中bool部分为false。吐过关键字不存在，元素被插入到容器中，且bool值为true。</p><h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><p>关联容器定义了三个版本的erase，如下图所示。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。者两个版本的erase与对应的顺序容器的操作非常相似；指定的元素被删除，函数返回void。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/L8DfFk13h5.jpg?imageslim" alt="mark"></p><h3 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a>11.3.4 map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应at函数。set类型不支持下标运算符。map下标预算符接受一个索引，获取与此关键字 相关联的值。但是，与其他下标运算符不同的是，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">//empty map</span></div><div class="line"><span class="comment">//插入一个关键字为Anna的元素，关联值进行值初始化；然后将1赋予它</span></div><div class="line">word_count[<span class="string">"Anna"</span>] = <span class="number">1</span>;</div></pre></td></tr></table></figure></p><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/32jkcDBE2E.jpg?imageslim" alt="mark"></p><h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><p>关联容器提供多种查找一个指定元素的方法。如果我们关心的是一个特定的元素是否在容器中，可能find是最佳选择。对于不允许重复关键字的容器，可能使用find还是count没有区别。但是对于允许重复关键字的容器，count还会做更多工作。如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用find。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/LCca3HlBAF.jpg?imageslim" alt="mark"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/fD8EL6Im2d.jpg?imageslim" alt="mark"></p><p>lower_bound和upper_bound这两个操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配的给定关键字的元素之后的位置。如果元素不在mulitmap中，则lower_bound和upper_bound会返回相等的迭代器-指向一个不影响排序的关键字插入位置。因此，相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围，表示具有该关键字的元素的范围。如果没有元素与给定的关键字匹配，则lower_bound和upper_bound会返回相等的迭代器，都指向给定关键字的插入点，能保持容器中元素顺序的插入位置。</p><p>equal_range函数，接受一个关键字，返回一个迭代器pair，如果关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。如果未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。</p><h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><p>新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素的，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高，此时无序容器也很有用。</p><p>除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。</p><p>无序容器管理的操作如下图所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171005/Gh1LJIm29F.jpg?imageslim" alt="mark"></p><p><strong>无序容器对关键字类型的要求</strong><br>默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。我们可以直接定义关键字是内置类型（包括指针类型）、string还是只能指针类型的无序容器。</key_type></p><p>但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素时一些关键字-值（key-value）对：关键字起到索引的作用，值则表示索引相关连的数据。set中每个元素只包含一个关键字；set支持高效的关键字查询操作-检查一个给定的关键字是否在set中。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第9章 顺序容器</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC9%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>https://ilewseu.github.io/2017/10/10/第9章-顺序容器/</id>
    <published>2017-10-10T15:16:28.000Z</published>
    <updated>2017-10-10T15:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个容器是一些特定类型的对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖与元素的值，而是与容器加入元素时的位置相对应。标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。<br><a id="more"></a></p><h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><p>下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p></blockquote><ul><li>向容器添加或从容器中删除元素的代价。</li><li>非顺序访问容器中元素的代价。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/FB384hJJL5.jpg?imageslim" alt="mark"></li></ul><p><strong>确定使用哪种顺序容器</strong><br>以下是一些选择容器的基本原则：</p><ul><li>除非有很好的理由选择其他容器，否则应使用vector。</li><li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list</li><li>程序要求随机访问元素，应使用vector或deque。</li><li>如果程序要求在容器中间插入或删除元素，应使用list或forward_list。</li><li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。</li><li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则<ul><li>​首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。</li><li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到vector中。</li></ul></li></ul><h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><p>本节中，介绍的所有容器都适用的操作。一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义在头文件deque中，list定义在头文件list中，以此类推。容器均定义为模板类。必须提供额外信息来生成特定的容器类型。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/EkGdfdCHEi.jpg?imageslim" alt="mark"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/7g56d7kBEC.jpg?imageslim" alt="mark"></p><h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><p><strong>迭代器范围</strong></p><p>一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者尾元素之后的位置。这两个迭代器通常被称为beign和end，或者是first和last，它们标记了容器中元素的一个范围。beign和end是一个左闭合区间，其标准数学描述为：<br>[beign, end)<br>表示范围自begin开始，于end之前结束。迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。<br>假定begin和end构成一个合法的迭代器范围，则：</p><ul><li>如果begin和end相等，则范围为空。</li><li>如果begin与end不相等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。</li><li>我们可以对begin递增若干次，使得begin==end。</li></ul><h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><p>类型别名，通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的value_type。如果需要元素类型的一个引用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程中非常有用。</p><h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数，除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/1kBi4bLdL0.jpg?imageslim" alt="mark"></p><p><strong>将一个容器初始化为另一个容器的拷贝</strong></p><p>将一个新容器创建为另一个容器的拷贝方法有两种：</p><ul><li>直接拷贝整个容器。</li><li>（array除外）拷贝有一个迭代器对指定的元素范围。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Milton"</span>,<span class="string">"Shakespeare"</span>,<span class="string">"Austen"</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>&#125;;</div><div class="line"></div><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; list2(authors); <span class="comment">//正确：类型匹配</span></div><div class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; authList(authors); <span class="comment">//错误：容器类型不匹配</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words(articles); <span class="comment">//错误：容器类型不匹配</span></div><div class="line"><span class="comment">//正确：可以将const char * 元素转换为string</span></div><div class="line">forward_list&lt;<span class="built_in">string</span>&gt; words(articles.begin(), articles.end());</div></pre></td></tr></table></figure></li></ul><blockquote><p>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。</p></blockquote><p><strong>与顺序容器大小相关的构造函数</strong></p><p>处理与关联容器相同的构造函数外，顺序容器（array）还提供了另一个构造函数，它接受一个容器大小和一个可选元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>,<span class="number">-1</span>); <span class="comment">//10个int元素，每个都初始化为-1；</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>, <span class="string">"hi!"</span>);</div><div class="line">forward_list&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>); <span class="comment">//10个元素，每个都初始化为0</span></div><div class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>);   <span class="comment">//10个元素，每个都是空string</span></div></pre></td></tr></table></figure></p><blockquote><p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持</p></blockquote><h3 id="9-2-5-赋值和swap"><a href="#9-2-5-赋值和swap" class="headerlink" title="9.2.5 赋值和swap"></a>9.2.5 赋值和swap</h3><p>下图列出了与赋值相关的运算符可以用于所有容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c1 = c2; <span class="comment">//将c1的内容替换为c2中元素的拷贝</span></div><div class="line">c1 = &#123;a,b,c&#125;; <span class="comment">//赋值后，c1大小为3</span></div></pre></td></tr></table></figure></p><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/b369dDhcFD.jpg?imageslim" alt="mark"></p><p><strong>使用assign（仅顺序容器）</strong></p><p>顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，可以使用assign实现将一个vector中的一段char*值赋予一个list中的string：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</div><div class="line">names = oldstyle;   <span class="comment">//错误：容器类型不匹配</span></div><div class="line"><span class="comment">//正确：可以将const char* 转换为string</span></div><div class="line">names.assign(oldstyle.cbegin(), oldstyle.cend());</div></pre></td></tr></table></figure></p><p>assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中的原有的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist1(<span class="number">1</span>); <span class="comment">//1个元素，为空string</span></div><div class="line"><span class="built_in">list</span>.assign(<span class="number">10</span>,<span class="string">"Hiya!"</span>); <span class="comment">//10个元素，每个都是"Hiya!"</span></div></pre></td></tr></table></figure></p><p><strong>使用swap</strong></p><p>swap操作交换两个相同类型的容器的内容，调用swap之后，两个容器中的元素将会交换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec1(<span class="number">10</span>); <span class="comment">//10个元素的vector</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2(<span class="number">24</span>); <span class="comment">//24个元素的vector</span></div><div class="line">swap(svec1,svec2);</div></pre></td></tr></table></figure></p><p>调用swap后，svec1将包含24个元素，svec2将包含10个元素。除了array外，交换两个容器内容的操作保证会很快–元素本身并未交换，swap只是交换了两个容器内部的数据结构。与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。</p><h2 id="9-3-顺序容器的操作"><a href="#9-3-顺序容器的操作" class="headerlink" title="9.3 顺序容器的操作"></a>9.3 顺序容器的操作</h2><h2 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h2><p>除了array外，所有的标准容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器的大小。下图列出了向顺序容器添加元素的操作。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/d7CAgmBh0F.jpg?imageslim" alt="mark"></p><p><strong>使用push_back</strong></p><p>push_back将一个元素追加到一个vector的尾部。除了array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。</p><blockquote><p>关键概念：容器元素时拷贝<br> 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后，对容器中元素的任何改变都不会影响到原始对象，反之依然。</p></blockquote><p><strong>使用push_front</strong><br>除了push_back、list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix!=<span class="number">4</span>; ++ix)</div><div class="line">ilist.push_front(ix);</div></pre></td></tr></table></figure></p><p><strong>在容器中特定位置添加元素</strong></p><p>insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素位置，而且在容器开始位置插入元素是很有用的功能，所以<strong>insert函数将元素插入到迭代器所指定的位置之前</strong>。</p><p><strong>使用emplace操作</strong><br>新标准引用三个新成员-emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p><h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/6keDeID9mE.jpg?imageslim" alt="mark"></p><p><strong>访问成员函数返回的是引用</strong></p><p>在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!c.empty())</div><div class="line">&#123;</div><div class="line">c.front() = <span class="number">42</span>; <span class="comment">//将42赋予c中的第一个元素</span></div><div class="line"><span class="keyword">auto</span> &amp;v = c.back(); <span class="comment">//获得指向最后一个元素的引用</span></div><div class="line">v = <span class="number">1024</span>; <span class="comment">//改变c中的元素</span></div><div class="line"><span class="keyword">auto</span> v2 = c.back(); <span class="comment">//v2不是一个引用，他是c.back()的一个拷贝</span></div><div class="line">v2 = <span class="number">0</span>; <span class="comment">//未改变c中的元素。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>下标操作和安全的随机访问</strong></p><p>提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。下标运算符接受一个下标参数，返回容器中该位置元素的引用。给定下标必须在“在范围内”。如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常。</p><h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><p>与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下图所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/eIbdKmiHb0.jpg?imageslim" alt="mark"></p><blockquote><p>删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须要确保它们是存在的。</p></blockquote><p><strong>pop_front和pop_back成员函数</strong></p><p>pop_fron和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似地，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。</p><p><strong>从容器内部删除一个元素</strong></p><p>成员函数erase从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定范围内的所有元素。两种形式的erase都返回指向删除的元素之后的位置的迭代器。即，若j是i之后的元素，那么erase（i）将返回指向j的迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> it = lst.begin();</div><div class="line"><span class="keyword">while</span> (it!=lst.end())</div><div class="line"><span class="keyword">if</span>(*it%<span class="number">2</span>)    <span class="comment">//若元素为奇数</span></div><div class="line">it = lst.erase(it); <span class="comment">//删除此元素  </span></div><div class="line"><span class="keyword">else</span></div><div class="line">++it;</div></pre></td></tr></table></figure></p><p><strong>删除多个元素</strong><br>接受一对迭代器的erase版本允许我们删除一个范围内的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">elem1 = slist.erase(elem1, elem2); <span class="comment">//调用后，elem1 == elem2</span></div></pre></td></tr></table></figure></p><h3 id="9-3-5-改变容器的大小"><a href="#9-3-5-改变容器的大小" class="headerlink" title="9.3.5 改变容器的大小"></a>9.3.5 改变容器的大小</h3><p>如下图所示，我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素都会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/3003jlhb6c.jpg?imageslim" alt="mark"></p><h3 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或者迭代器失效。在向容器添加元素后：</p><ul><li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重现分配，指向插入位置之前的元素迭代器、指针和引用仍会有效，但指向插入位置之后元素的迭代器，指针和引用将会失效。</li><li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li><li>对于list和forward_list，指向容器的迭代器、指针和引用仍有效。</li></ul><p>当我们删除一个元素后：</p><ul><li>对于list和forward_list，指向容器其他位置的迭代器、引用和指针仍有效。</li><li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不会受影响；如果是删除首元素，这些页不会受影响。</li><li>对于vector和string，指向被删元素之前的迭代器、引用和指针仍有效<br><strong>注意：当我们删除元素时，尾后迭代器总是会失效。</strong></li></ul><h2 id="9-4-vector-对象是如何增长的"><a href="#9-4-vector-对象是如何增长的" class="headerlink" title="9.4 vector 对象是如何增长的"></a>9.4 vector 对象是如何增长的</h2><p>标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。</p><p><strong>管理容器的成员函数</strong></p><p>vector和string类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动。capacity操作告诉我们容器在不扩展内存空间的情况下可以容纳多个元素。reverse操作允许我们通知容器它应该准备保存多少个元素。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/CjkDkl0aHf.jpg?imageslim" alt="mark"><br>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。<br>只有当需要的内存空间超过当前容量时，reverse调用才会改变vector的容量。如果需求大小大于当前容量，reverse至少分配与需求一样大的内存空间。如果需求大小小于或等于当前容量，reverse什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reverse之后，capacity将会大于或等于传递给reverse的参数。</p><p><strong>capacity和size</strong><br>容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p><blockquote><p>每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。</p></blockquote><h2 id="9-5-string的额外操作"><a href="#9-5-string的额外操作" class="headerlink" title="9.5 string的额外操作"></a>9.5 string的额外操作</h2><p>除了顺序容器共同的操作之外，string类型还提供了一些额外的操作。这些操作中的大部分要么提供string类和C风格字符数组之间的相互转换，要么是增加了允许我们用下标代替迭代器的版本。标准库string类型定义了大量函数。幸运的是，这些函数使用了重复的模式。</p><h3 id="9-5-1-构造string的其他方法"><a href="#9-5-1-构造string的其他方法" class="headerlink" title="9.5.1 构造string的其他方法"></a>9.5.1 构造string的其他方法</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/df336FI4lJ.jpg?imageslim" alt="mark"></p><h3 id="9-5-2-改变string的其他方法"><a href="#9-5-2-改变string的其他方法" class="headerlink" title="9.5.2 改变string的其他方法"></a>9.5.2 改变string的其他方法</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/1IDKjHIHaE.jpg?imageslim" alt="mark"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/F9iDF1E7gH.jpg?imageslim" alt="mark"></p><h3 id="9-5-3-string的搜索操作"><a href="#9-5-3-string的搜索操作" class="headerlink" title="9.5.3 string的搜索操作"></a>9.5.3 string的搜索操作</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/7260d6c87a.jpg?imageslim" alt="mark"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/20C7E2hJj1.jpg?imageslim" alt="mark"></p><h3 id="9-5-4-compare函数"><a href="#9-5-4-compare函数" class="headerlink" title="9.5.4 compare函数"></a>9.5.4 compare函数</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/gfEJJIldl8.jpg?imageslim" alt="mark"></p><h3 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/dfI6F1GbeK.jpg?imageslim" alt="mark"></p><h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><p>除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/00FfCbCHAD.jpg?imageslim" alt="mark"></p><p><strong>栈适配器</strong><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/6K6em80afC.jpg?imageslim" alt="mark"></p><p><strong>队列适配器</strong><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/F6E3HAL768.jpg?imageslim" alt="mark"><br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171004/7k8mf21L2l.jpg?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个容器是一些特定类型的对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖与元素的值，而是与容器加入元素时的位置相对应。标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第6章 函数</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC6%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
    <id>https://ilewseu.github.io/2017/10/10/第6章-函数/</id>
    <published>2017-10-10T15:16:10.000Z</published>
    <updated>2017-10-10T15:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><p>一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对括号之内。</p><p><strong>调用函数</strong></p><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调函数。此时，主调函数的执行被暂时中断，被调函数开始执行。<br><a id="more"></a><br><strong>形参和实参</strong></p><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。实参的类型必须与对应的形参类型匹配，这一点与之前的规则是一致的。函数有几个形参，我们就必须提供相同数量的实参。</p><p><strong>函数的形参列表</strong></p><p>函数的形参列表可以为空，但是不能省略。想要定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。不过为了与C语言兼容，也可以使用关键字void表示函数没有形参：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125; <span class="comment">//隐式地定义空形参列表</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;<span class="comment">/*...*/</span>&#125; <span class="comment">//显示地定义空形参列表</span></div></pre></td></tr></table></figure></p><p>任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p><h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h3><p>在c++语言中，名字有作用域，对象有声明周期。理解这两个概念非常重要。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见。</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间。<br>形参和函数体内部定义的变量统称为局部变量。</li></ul><p><strong>自动对象</strong></p><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。当块的执行结束之后，块中创建的自动对象的值就变成未定义的了。<br>形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参页就被销毁。</p><p><strong>局部静态对象</strong></p><p>某些时候，有必要令局部变量的声明周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h3><p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。</p><h3 id="6-1-3-分离式编译"><a href="#6-1-3-分离式编译" class="headerlink" title="6.1.3 分离式编译"></a>6.1.3 分离式编译</h3><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同的文件中。为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持分离式编译，分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><p>和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋值给形参。<br>当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。</p><p><strong>指针形参</strong></p><p>指针的行为和其他引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值，拷贝后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。</p><p><strong>使用引用避免拷贝</strong></p><p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p><blockquote><p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p></blockquote><h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h3><p>顶层const作用于对象本身：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>; <span class="comment">//不能改变ci，const是顶层的</span></div><div class="line"><span class="keyword">int</span> i = ci； <span class="comment">//正确：当拷贝ci时，忽略了它的顶层const</span></div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;i; <span class="comment">//const是顶层的，不能给p赋值</span></div><div class="line">*p = <span class="number">0</span>； <span class="comment">//正确：通过p改变对象的内容是允许的，现在i变成了0</span></div></pre></td></tr></table></figure></p><p>和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层的const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。<br>想要调用引用版本的reset函数，只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象。类似的，要想调用指针版的reset只能使用int*。另一方面，我们能传递一个字符串字面值作为find_char的第一个实参，这是因为该函数的引用形参是常量引用，而c++允许我们用字面值初始化常量引用。</p><h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响。这两个性质分别是：不允许拷贝数组以及使用数组时会将其转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组元素的指针。尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尽管形式不同，但这三个print函数是等价的，每个函数都有一个const int* 类型的形参</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p><p>因为数组是以指针的形式传递给函数的，所有一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。</p><p><strong>使用标记指定数组长度</strong><br>管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。</p><p><strong>使用标准库规范</strong><br>管理数组实参的第二种技术是传递指向数组首元素和尾元素的指针。</p><p><strong>显示传递一个表示数组大小的形参</strong><br>第三种管理数组实参的方法是专门定义第一个表示数组大小的形参。</p><p><strong>数组引用形参</strong></p><p>C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确：形参是数组的引用，维度是类型的一部分</span></div><div class="line">void print(int (&amp;arr)[10])</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> elem: arr)</div><div class="line">  <span class="built_in">cout</span> &lt;&lt;elem&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>传递多维数组</strong></p><p>C++中实际上没有真正的多维数组，所谓的多维数组其实就是数组的数组。和所有数组一样，将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面的所有维度）的大小都是数组类型的一部分，不能省略。</p><p>###6.2.6 含有可变形参的函数</p><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板。<br>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。</p><p><strong>initializer_list形参</strong></p><p>如果函数的实参数量未知，但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名头文件中，它提供的操作如表6.1所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171003/4LeAHlkj51.jpg?imageslim" alt="mark"></p><p><strong>省略形参</strong></p><p>省略形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。<br>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎一下两种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(param_listm, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</div></pre></td></tr></table></figure></p><p>第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参对应的实参无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。</p><h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return语句有两种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> ;</div><div class="line"><span class="keyword">return</span> expression;</div></pre></td></tr></table></figure></p><h3 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a>6.3.1 无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。<br>一个返回类型的void的函数也能使用return语句的第二种形式，不过此时return语句的expression必须是另一个返回的void函数。强行令void函数返回其他类型的表达式将产生编译错误。</p><h3 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a>6.3.2 有返回值函数</h3><p>return语句的第二种形式提供了函数的结果，只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句的返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p><p><strong>不要返回局部对象的引用或指针</strong><br>函数完成之后，它所占用的存储空间也随之被释放掉，因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p><p><strong>返回类类型的函数和调用运算符</strong></p><p>和其他运算符一样，调用运算符也有优先级和结合律，调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，<strong>如果函数返回指针、引用或类的对象，我们就能够适应函数调用的结果访问结果的对象的成员</strong>。</p><p><strong>引用返回左值</strong></p><p>函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的得结果赋值。</p><p><strong>列表初始化返回值</strong></p><p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表页用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p><h3 id="6-3-3-返回函数指针"><a href="#6-3-3-返回函数指针" class="headerlink" title="6.3.3 返回函数指针"></a>6.3.3 返回函数指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>]; <span class="comment">//arrT是一个类型别名，它表示类型是含有10个整数的数组</span></div><div class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//arrT的等价声明</span></div><div class="line"><span class="function">arrT* <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span>;     <span class="comment">//func 返回一个指向含有10个整数的数组的指针</span></div></pre></td></tr></table></figure></p><p>返回数组指针的函数的形式如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Type (*function(parameter_list))[dimension]</div></pre></td></tr></table></figure></p><p>例如，下面这个func函数的声明没有使用类型别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i)) [<span class="number">10</span>];</div></pre></td></tr></table></figure></p><p>可以按照以下的顺序来逐层理解该声明的含义：</p><ul><li>func(int i) 表示调用func函数时需要一个int类型的实参。</li><li>(* func(int i)) 意味着我们可以对函数调用的结果执行解引用操作。</li><li>(*func(int i))[10] 表示解引用func的调用将得到一个大小是10的数组。</li><li>int (* func(int i))[10] 表示数组中的元素类型是int类型。</li></ul><p><strong>使用尾置返回类型</strong></p><p>在C++11新标准种还有一种可以简化上述func声明的方法，就是使用<strong>使用尾置返回类型</strong>。任何函数的定义都能使用尾置返回，但这种形式对于返回类型比较复杂的函数比较有效。比如，返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本该出现返回类型的地方放置一个auto：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></div><div class="line">auto func(int i) -&gt; int(*)[10];</div></pre></td></tr></table></figure></p><h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载（overload）函数</strong>。这些函数接收的形参类型不一样，但是执行出的操作非常相似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。<br>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。</p><blockquote><p>main函数不能重载</p></blockquote><p>对于重载函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外，其他的所有要素都相同。</p><p><strong>重载和const形参</strong><br>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另外一个没有顶层const的形参区分开来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</div><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>; <span class="comment">//重复声明了Record lookup（Phone）</span></div><div class="line"></div><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone *)</span></span>;</div><div class="line"><span class="function">Recode <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">//重复声明了Record lookup（Phone *）</span></div></pre></td></tr></table></figure></p><p>另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的常量对象还是非常量对象可以实现函数重载，此时的const是底层的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account &amp;)</span></span>;</div><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>; <span class="comment">//新函数，作用于常量引用</span></div><div class="line"></div><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account *)</span></span>;  <span class="comment">//新函数，作用于指向Account的指针</span></div><div class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account *)</span></span>; <span class="comment">//新函数，作用于指向常量的指针</span></div></pre></td></tr></table></figure></p><p><strong>调用重载的函数</strong></p><p><strong>函数匹配</strong>是指一个过程，在这个过程，我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做<strong>重载确定</strong>。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。<br>当调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。</li><li>找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。</li><li>有多个一个函数可以匹配，但是每一个都不是明显的最佳选择。此时，也将发生错误，称为二义性调用。</li></ul><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><p>某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的<strong>默认实参</strong>。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。在定义函数时，我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。<strong>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面</strong>。</p><p><strong>默认实参声明</strong></p><p>对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意的是，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h3><p><strong>内联函数可以避免函数调用的开销</strong><br>将函数指定为内联函数（inline），通常就是将它再每个调用点上“内联地”展开。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。</p><p><strong>constexpr函数</strong><br>constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz(); <span class="comment">//正确：foo是一个常量表达式</span></div></pre></td></tr></table></figure></p><blockquote><p>constexpr 函数不一定返回常量表达式</p></blockquote><p><strong>把内联函数和constexpr函数放在头文件内</strong></p><p>和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟编译器想要展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，<strong>内联函数和constexpr函数通常定义在头文件</strong>。</p><h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><p><strong>确定候选函数和可行函数</strong></p><p>函数匹配的第一步就是选定本次调用对应的重载函数集，集合中的函数称为<strong>候选函数</strong>。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。<br>第二步是考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为“可行函数”。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能够转换成形参的类型。</p><p><strong>寻找最佳匹配</strong></p><p>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行的函数。基本思想是，实参类型与形参类型越接近，它们匹配得越好。</p><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：</p><ol><li>精确匹配，包括以下情况：<ul><li>实参类型和形参类型相同。</li><li>实参从数组类型或函数类型转换成对应的指针类型。</li><li>向实参添加顶层const或者从实参中删除顶层const。</li></ul></li><li>通过const转换实现的匹配。</li><li>通过类型提升实现的匹配。</li><li>通过算术类型转换或者指针转换实现的匹配。</li><li>通过类类型转换实现的匹配。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;6-1-函数基础&quot;&gt;&lt;a href=&quot;#6-1-函数基础&quot; class=&quot;headerlink&quot; title=&quot;6.1 函数基础&quot;&gt;&lt;/a&gt;6.1 函数基础&lt;/h2&gt;&lt;p&gt;一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对括号之内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调函数。此时，主调函数的执行被暂时中断，被调函数开始执行。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第3章 字符串、向量和数组</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>https://ilewseu.github.io/2017/10/10/第3章-字符串、向量和数组/</id>
    <published>2017-10-10T15:15:49.000Z</published>
    <updated>2017-10-10T15:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><p>需要注意的事项：</p><ul><li>每个名字都需要独立的using声明</li><li>头文件不应包含using声明</li></ul><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><p>标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。包含头文件的代码如下：<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div></pre></td></tr></table></figure></p><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><table><thead><tr><th><strong>初始string对象的方式</strong></th></tr></thead><tbody><tr><td>string s1                     默认初始化，s1是一个空串</td></tr><tr><td>string s2(s1)               s2是s1的副本</td></tr><tr><td>string s3(“value”)        s3是字面值“value”的副本，除了字面值最后的空字符外</td></tr><tr><td>string s3=“value”          等价于s3(“value”)，s3是字面值”value”的副本</td></tr><tr><td>string s4(n, ‘c’)               把s4初始化为连续n个字符c组成的串</td></tr></tbody></table><p><strong>直接初始化和拷贝初始化</strong></p><p>c++语言有几种不同的初始化方式，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是<strong>直接初始化</strong>。</p><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><p>string对象上的操作如下图所示：</p><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171003/28jlaIJK5k.jpg?imageslim" alt="mark"></p><p><strong>读取未知数量的string对象</strong></p><p>下面的代码用于读取未知数量的string对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">string</span> word;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;word)   <span class="comment">//反复读取，直到到达文件末尾</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; word&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>使用getline读取一整行</strong></p><p>有时我们希望在最终得到的字符串中保留输入的空白字符，这时应该使用<strong>getline</strong>函数代替原来的<strong>&gt;&gt;</strong>运算符。<strong>getline</strong>函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止，然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。下面是一段示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">string</span> line;</div><div class="line">  <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,line))</div><div class="line">  <span class="built_in">cout</span> &lt;&lt;line&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3 处理string对象中的字符"></a>3.2.3 处理string对象中的字符</h3><p>cctype头文件定义了一组标准库函数处理字符串，其具体的函数如下图说所示：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171003/faEkcLiFjL.jpg?imageslim" alt="mark"><br><strong>处理每个字符？使用基于范围的for语句</strong><br>如果想对string对象中的每个字符做点什么操作，目前最好的办法是使用C++11新标准提供的语句：范围for（range for）语句。这种语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，其语法形式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(declaration: expression)</div><div class="line">statement</div></pre></td></tr></table></figure></p><p>其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。下面是遍历string对象的实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c: str)</div><div class="line"><span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。想要使用vector，必须包含适当的头文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</div></pre></td></tr></table></figure></p><p><strong>vector</strong>是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如，vector<int>。vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所有不存在包含引用的vector。除此之外，其他大多数内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。</int></p><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171003/I63HECKa4f.jpg?imageslim" alt="mark"><br>主要类型可以分为如下几类：</p><ul><li>默认初始化</li><li>列表初始化vector对象</li><li>创建指定数量的元素初始化，例如：vector<int> ivec(10, -1);</int></li><li>值初始化，例如，vector<int> ivec(10)，10个元素，每个都初始化为0</int></li></ul><h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a>3.3.2 向vector对象中添加元素</h3><p>使用push_back()方法可以向vector对象中添加元素。</p><h3 id="3-3-3-vector的其他操作"><a href="#3-3-3-vector的其他操作" class="headerlink" title="3.3.3 vector的其他操作"></a>3.3.3 vector的其他操作</h3><p><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171003/geBICKJIal.jpg?imageslim" alt="mark"></p><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p><strong>迭代器的运算符</strong><br>下表列举了迭代器支持的一些运算。使用==和!=来比较两个合适的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等；否则就说两个迭代器不相等。</p><table><thead><tr><th><strong>标准容器迭代器的运算符</strong></th></tr></thead><tbody><tr><td>*iter                      返回迭代器iter所指元素的引用</td></tr><tr><td>iter-&gt;mem            解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td></tr><tr><td>++iter                    令iter指示容器中的下一个元素</td></tr><tr><td>–iter                       令iter指示容器的上一个元素</td></tr><tr><td>iter1 == iter2          判断两个迭代器是否相等，如果两个迭代器指示的同一个元素</td></tr><tr><td>iter1!=iter2              或者它们是同一个容器的尾后迭代器，则相等；反之，不相等</td></tr></tbody></table><p><strong>begin和end运算符</strong></p><p>begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator；</p><p><strong>结合解引用和成员访问操作</strong></p><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就可以进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it为vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(*it).empty()</div></pre></td></tr></table></figure></p><p>为了简化上述表达式，C++语言定义了<strong>箭头运算符-&gt;</strong>。箭头运算符把解引用和成员访问操作结合在一起，也就是说，iter-&gt;mem和(*it).mem表达的意思相同。</p><h3 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a>3.4.2 迭代器运算</h3><p>string和vector的迭代器提供了很多额外的运算符，一方面可使得迭代器的每次移动跨过对多个元素，另外也支持迭代器进行关系运算，具体如下图：<br><img src="http://of6h3n8h0.bkt.clouddn.com/blog/171003/2HHki21G2L.jpg?imageslim" alt="mark"></p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为，数组的大小固定，因此对某些特殊的应用来说程序的运行时性能比较好，但是相应的损失了一些灵活性。</p><p><strong>指针和数组</strong><br>在C++语言中，指针和数组有非常紧密的联系，使用数组的时候编译器一般会把它转换为指针。通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此，像其他元素一样，对数组的元素使用取地址符就能的得到指向该元素的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</div><div class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; <span class="comment">//p指向numsde 第一个元素</span></div></pre></td></tr></table></figure></p><p>数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> *p2 = nums; <span class="comment">//等价于p2 = &amp;nums[0]</span></div></pre></td></tr></table></figure></p><p>由此，可知在一些情况系数组的操作实际上是指针的操作，当使用数组作为auto变量的初始值时，推断得到的类型是指针而非数组。</p><p><strong>指针也是迭代器</strong><br>指向数组元素的指针拥有更多功能。vector和string的迭代器支持的运算，数组的指针全部支持。尽管能够计算得到尾后指针，但这种用法易出错。C++11标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员的功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为他们的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">int</span> *beg = begin(ia); <span class="comment">//指向ia首元素的指针</span></div><div class="line"><span class="keyword">int</span> *last = end(ia);  <span class="comment">//指向ia尾元素的的下一个位置的指针</span></div></pre></td></tr></table></figure></p><p>begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。</p><p><strong>解引用和指针运算的交互</strong><br>指针加上一个整数所得的结果还是一个指针。假设结果指针指向一个元素，则允许解引用该结果指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</div><div class="line"><span class="keyword">int</span> last = *(ia+<span class="number">4</span>);   <span class="comment">//正确：把last初始化为8，也就是ia[4]的值</span></div></pre></td></tr></table></figure></p><p>最好在必要的地方加上括号，类似的，上例中指针加法的圆括号也必不可少。如果写成下面的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last = *ia + <span class="number">4</span>;  <span class="comment">// 正确：last=4等价于ia[0]+4</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-1-命名空间的using声明&quot;&gt;&lt;a href=&quot;#3-1-命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;3.1 命名空间的using声明&quot;&gt;&lt;/a&gt;3.1 命名空间的using声明&lt;/h2&gt;&lt;p&gt;需要注意的事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个名字都需要独立的using声明&lt;/li&gt;
&lt;li&gt;头文件不应包含using声明&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-标准库类型string&quot;&gt;&lt;a href=&quot;#3-2-标准库类型string&quot; class=&quot;headerlink&quot; title=&quot;3.2 标准库类型string&quot;&gt;&lt;/a&gt;3.2 标准库类型string&lt;/h2&gt;&lt;p&gt;标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。包含头文件的代码如下：&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第2章 变量和基本类型</title>
    <link href="https://ilewseu.github.io/2017/10/10/%E7%AC%AC2%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://ilewseu.github.io/2017/10/10/第2章-变量和基本类型/</id>
    <published>2017-10-10T15:15:19.000Z</published>
    <updated>2017-10-10T15:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><p> C++提供了一套包括算术类型和空类型在内的基本数据类型。其中，算术类型包括字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。</p><a id="more"></a><h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 <strong>算术类型</strong></h3><p>算术类型分为两类：整型（包括字符和布尔类型）和浮点型。C++算数类型如下表所示：</p><table><thead><tr><th style="text-align:left"><strong>含义</strong></th><th style="text-align:left"><strong>类型</strong></th><th style="text-align:left"><strong>最小尺寸</strong></th></tr></thead><tbody><tr><td style="text-align:left">布尔类型</td><td style="text-align:left">bool</td><td style="text-align:left">未定义</td></tr><tr><td style="text-align:left">字符</td><td style="text-align:left">char</td><td style="text-align:left">8位</td></tr><tr><td style="text-align:left">宽字符</td><td style="text-align:left">wchar_t</td><td style="text-align:left">16位</td></tr><tr><td style="text-align:left">Unicode字符</td><td style="text-align:left">char16_t</td><td style="text-align:left">16位</td></tr><tr><td style="text-align:left">Unicode字符</td><td style="text-align:left">char32_t</td><td style="text-align:left">32位</td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:left">short</td><td style="text-align:left">16位</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int</td><td style="text-align:left">16位</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:left">long</td><td style="text-align:left">32位</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:left">long long</td><td style="text-align:left">64位</td></tr><tr><td style="text-align:left">单精度浮点数</td><td style="text-align:left">float</td><td style="text-align:left">6位有效数字</td></tr><tr><td style="text-align:left">双精度浮点数</td><td style="text-align:left">double</td><td style="text-align:left">10位有效数字</td></tr><tr><td style="text-align:left">扩展精度浮点数</td><td style="text-align:left">long double</td><td style="text-align:left">10位有效数字</td></tr></tbody></table><p>除去布尔型和扩展的字符型之外，其他整型可以划分为<strong>带符号的（singed）</strong>和<strong>无符号（unsigned）</strong>的两种。带符号类型可以表示正数、负数和0，无符号的类型仅能表示大于等于0的值。int、short、long和long long都是带符号的，通过在这些类型前添加unsigned就可以得到无符号类型。<strong>与其他整型不同，字符型被分为了三种：char、signed char和unsigned char</strong>。尽管字符型有三种，但是字符型的表现形式只有两种：带符号的和无符号的。</p><p><strong>如何选择合适的类型</strong></p><ul><li>当明确知晓数值不可能为负时，选择无符号类型。</li><li>使用int执行整数运算。在实际使用中short常常显得太小，long一般和int有一样的尺寸。如果数值超过了int的表示范围，选用long long。</li><li>在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用他们。因为类型char在一些机器上是由符号的，而在另一些机器上又是无符号的，所有如果使用char进行运算特别容易出现问题。如果使用的整数为一个不大的整数，那么明确指定它的类型是singed char或unsigned char。</li><li>执行浮点数运算选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。</li></ul><p>###2.1.2 类型转换<br>C++类型转换时的处理操作：</p><ul><li>将非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为false，否则结果为true。</li><li>将布尔值赋给非布尔类型时，初始值为false结果为0，初始值为true结果为1。</li><li>将浮点数赋值给整数类型时，进行近似处理，结果值将仅保留浮点数中小数点之前的部分。</li><li>将整数值赋值给浮点数时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li><li>当赋值给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</li><li>当赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。</li></ul><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p><strong>变量定义</strong></p><p>变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结果结束。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, value, uints_sold= <span class="number">0</span>;</div></pre></td></tr></table></figure></p><p><strong>变量初始化</strong></p><p>变量初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象当前值擦除，而以一个新的值来代替。</p><p><strong>列表初始化</strong></p><p>C++语言定义了初始化的好几种不同的形式，也是初始化问题复杂性的一个体现。例如，定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> units_sold=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</div></pre></td></tr></table></figure></p><p><strong>默认初始化</strong></p><p>如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值是由变量类型决定，同时定义变量的位置也会对此有影响。</p><p><strong>变量的声明和定义的关系</strong></p><p>为了允许把程序拆分为多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区分开来。<strong>声明</strong>使得名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的生明。而<strong>定义</strong>负责创建与名字关联的实体。变量的声明规定了变量的类型和名字，在这一点定义与之相同。但是除此之外，定义还申请存储空间，也可能会为一个变量赋初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而不是显示初始化变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//声明而非定义i</span></div><div class="line"><span class="keyword">int</span> j;        <span class="comment">//声明并定义j</span></div></pre></td></tr></table></figure></p><p>任何包含了显示初始化的声明即成为定义。在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p><blockquote><p>变量能且只能被定义一次，但是可以被多次声明。</p></blockquote><p><strong>变量的作用域</strong></p><p><strong>全局作用域</strong>，全局作用域内的变量在整个程序的范围内都可使用。如果函数有可能用到全局变量，则不宜再定义一个同名的局部变量。</p><h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><p><strong>引用（reference）</strong>为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</div><div class="line"><span class="keyword">int</span> &amp;refVal = ival; <span class="comment">//refVal指向ival（是ival的另一个名字）</span></div><div class="line"><span class="keyword">int</span> &amp;refVal2; <span class="comment">//报错:引用必须要被初始化</span></div></pre></td></tr></table></figure></p><p>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而，定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></blockquote><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。因为引用本身不是一个对象，所有不能定义引用的引用。</p><p><strong>引用的定义</strong></p><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;</div><div class="line"><span class="keyword">int</span> &amp;r = i, r2 = i2; <span class="comment">//r是一个引用，与i绑定在一起，r2是int</span></div><div class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;<span class="comment">//i3是int，ri是一个引用，与i3绑定在一起</span></div></pre></td></tr></table></figure></p><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><p><strong>指针</strong>是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。定义指针类型的方法是将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ip1, *ip2; <span class="comment">//ip1和ip2都是指向int型对象的指针</span></div><div class="line"><span class="keyword">double</span> dp, *dp2; <span class="comment">//dp2是指向double型对象的指针，dp是double类型对象</span></div></pre></td></tr></table></figure></p><p><strong>获取对象的地址</strong></p><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">//p存放变量ival的地址，或者说p是指向变量ival的指针</span></div></pre></td></tr></table></figure></p><p>指针的类型都要和它所指向的对象严格匹配。</p><p><strong>指针值</strong></p><p>指针的值（即地址）应属于下列4中状态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p><strong>利用指针访问对象</strong></p><p>如果指针指向了一个对象，则允许使用<strong>解引用符</strong>（操作符*）来访问该对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">//p存放着变量ival的地址</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *p ; <span class="comment">//由符号*得到指针p所指的对象，输出42</span></div></pre></td></tr></table></figure></p><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p  = <span class="number">0</span>;   <span class="comment">//由符号*得到指针p所指的对象，即可由p为变量ival赋值</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *p;<span class="comment">//输出0</span></div></pre></td></tr></table></figure></p><p><strong>空指针</strong></p><p><strong>空指针</strong>不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</div><div class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p><blockquote><p>建议：初始化所有指针</p></blockquote><p><strong>赋值和指针</strong></p><p>给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *pi2 = &amp;i;  <span class="comment">//pi2初始化，存有i的地址</span></div><div class="line"><span class="keyword">int</span> *pi3;       <span class="comment">//如果pi3定义于块内，则pi3的值是无法确定的</span></div><div class="line"></div><div class="line">pi3 = pi2;       <span class="comment">//pi3和pi2指向同一个对象i</span></div><div class="line">pi2 = <span class="number">0</span>;         <span class="comment">//pi2不指向任何对象了</span></div></pre></td></tr></table></figure></p><p>有时太想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指向的对象的值不太容易，<strong>最好的办法就是记住赋值永远改变等号左侧的对象</strong>。当写出如下语句时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pi = &amp;ival; <span class="comment">//pi的值被改变，现在pi指向了ival</span></div></pre></td></tr></table></figure></p><p>意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*pi = <span class="number">0</span>; <span class="comment">//ival的值被改变，指针pi并没有被改变</span></div></pre></td></tr></table></figure></p><p>则*pi（也就是指针pi指向的那个对象）发生改变。<br><strong>void*指针</strong></p><p><strong>void*</strong>是一种特殊的指针类型，可以用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。我们对该地址中到底是个什么类型的对象不了解。</p><p><strong>指向指针的指针</strong></p><p>通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</div><div class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">//pi指向一个int型的数</span></div><div class="line"><span class="keyword">int</span> **ppi = &amp;pi; <span class="comment">//ppi指向一个int型的指针</span></div></pre></td></tr></table></figure><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>当希望定义一种变量，它的值不能被改变，可以使用关键字<strong>const</strong>对变量类型加以限定。使其成为const对象，const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p><blockquote><p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字</p></blockquote><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 <strong>const的引用</strong></h3><p>可以把引用绑定在conster对象上，就像绑定到其他对象上一样，称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">//正确：引用及其对应的对象都是常量</span></div><div class="line">r1 = <span class="number">42</span>; <span class="comment">//错误：r1是对常量的引用</span></div><div class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误：试图让一个非常量音引用指向一个常量对象</span></div></pre></td></tr></table></figure></p><p><strong>初始化和对const的引用</strong></p><p>引用的类型必须与其所引用的对象的类型一致，但是有个例外：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值。<br>对const的引用可能引用一个并非const的对象。必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是一个非常量，所有允许通过其他途径改变它的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> &amp;r1 = i;   <span class="comment">//引用r1绑定对象i</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i; <span class="comment">//r2也绑定对象i，但是不允许通过r2修改i的值</span></div><div class="line">r1 = <span class="number">0</span>;        <span class="comment">//r1并非常量，i的值修改为0</span></div><div class="line">r2 = <span class="number">0</span>;     <span class="comment">//错误：r2是一个常量引用</span></div></pre></td></tr></table></figure><p>r2绑定整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。</p><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p><strong>指向常量的指针</strong>不能用于改变其所指对象的值。要想存放常量对象地址，只能使用指向常量的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;  <span class="comment">//pi是个常量</span></div><div class="line"><span class="keyword">double</span> *ptr = &amp;pi;    <span class="comment">//错误：ptr是一个普通的指针</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确：cptr可以指向一个双精度常量</span></div><div class="line">*cptr = <span class="number">42</span>;               <span class="comment">//错误：不能给*cptr赋值</span></div></pre></td></tr></table></figure></p><p>指针的类型必须与其所指对象的类型一致，例外情况是：允许令一个指向常量的指针指向一个非常量对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> deval = <span class="number">3.14</span>;</div><div class="line">cptr = &amp;deval;   <span class="comment">//正确：但是不能通过cptr改变deval的值</span></div></pre></td></tr></table></figure></p><p><strong>const指针</strong></p><p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量，即不变的是指针本身的值，而非指向的那个值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">//curErr将一直指向errNumb</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi  = <span class="number">3.14159</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">//pip是一个指向常量对象常量指针</span></div></pre></td></tr></table></figure></p><p>要想弄清楚这些声明的含义最有效的方法的是从右向左阅读。</p><h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p>类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用。有两种方法可以用于定义类型别名。传统的方法是使用关键字typedef：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages是double的同义词</span></div><div class="line"><span class="keyword">typedef</span> wages base,*p; <span class="comment">//base是double的同义词，p是double*的同义词</span></div></pre></td></tr></table></figure></p><p>新标准规定了一种新的方法，使用<strong>别名声明</strong>来定义类型的别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//SI是Sales_item的同义词</span></div></pre></td></tr></table></figure></p><h3 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h3><p>在编程时常常需要把表达式的值赋值给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而，有时根本做不到。为了解决这个问题，C++11新标准引用了<strong>auto</strong>类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量需要有初始值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> item = val1 + val2; <span class="comment">//item初始化为val1和val2相加的结果</span></div></pre></td></tr></table></figure></p><h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，<strong>C++ 11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x; <span class="comment">//sum的类型就是函数f的返回类型</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-基本内置类型&quot;&gt;&lt;a href=&quot;#2-1-基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 基本内置类型&quot;&gt;&lt;/a&gt;2.1 基本内置类型&lt;/h2&gt;&lt;p&gt; C++提供了一套包括算术类型和空类型在内的基本数据类型。其中，算术类型包括字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="https://ilewseu.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://ilewseu.github.io/tags/c/"/>
    
      <category term="读书笔记" scheme="https://ilewseu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
